import { QuizQuestion } from '../../types/quiz';

export const object_methodsQuizzes: QuizQuestion[] = [
{
    id: 'js-263',
    question: "üìù What's the output?\n\n```javascript\nconst obj = { a: 1, b: 2, c: 3 };\nconsole.log(Object.keys(obj));\nconsole.log(Object.values(obj));\n```",
    category: 'javascript',
    subcategory: 'object-methods',
    difficulty: 'easy',
    options: [
      "['a', 'b', 'c'] and [1, 2, 3]",
      "{a: 1, b: 2, c: 3} and {a: 1, b: 2, c: 3}",
      "[1, 2, 3] and ['a', 'b', 'c']",
      "Error",
    ],
    correctAnswer: 0,
    explanation: "**Object.keys() extracts property names, Object.values() extracts property values** - both return arrays!\n\n**Think of an object like a filing cabinet** - Object.keys() gives you the drawer labels, Object.values() gives you the contents!\n\n**What happens:**\n```javascript\nconst obj = { a: 1, b: 2, c: 3 };\n\n// Object.keys() - array of property names:\nObject.keys(obj);\n// ['a', 'b', 'c'] ‚úÖ\n\n// Object.values() - array of property values:\nObject.values(obj);\n// [1, 2, 3] ‚úÖ\n```\n\n**Common use cases:**\n```javascript\nconst user = { name: 'John', age: 30, city: 'NYC' };\n\n// Get all property names:\nObject.keys(user);\n// ['name', 'age', 'city']\n\n// Get all values:\nObject.values(user);\n// ['John', 30, 'NYC']\n\n// Count properties:\nObject.keys(user).length;  // 3\n\n// Loop over keys:\nObject.keys(user).forEach(key => {\n  console.log(key, user[key]);\n});\n```\n\n**Order is preserved:**\n```javascript\nconst obj = { z: 3, a: 1, m: 2 };\n\nObject.keys(obj);    // ['z', 'a', 'm']\nObject.values(obj);  // [3, 1, 2]\n// Insertion order maintained!\n```\n\n**Memory trick:** keys = labels, values = contents, both return arrays!",
    tags: ['objects', 'object-methods'],
  },

{
    id: 'js-264',
    question: "üìù What's the output?\n\n```javascript\nconst obj = { a: 1, b: 2 };\nconst copy = Object.assign({}, obj);\n\ncopy.a = 99;\nconsole.log(obj.a);\n```",
    category: 'javascript',
    subcategory: 'object-methods',
    difficulty: 'easy',
    options: [
      '99',
      '1',
      'undefined',
      'Error',
    ],
    correctAnswer: 1,
    explanation: "**Object.assign() creates a shallow copy** - primitives are copied by value, objects by reference!\n\n**Think of Object.assign() like photocopying a document** - text is duplicated, but sticky notes (references) point to the same shared location!\n\n**What happens:**\n```javascript\nconst obj = { a: 1, b: 2 };\nconst copy = Object.assign({}, obj);\n// copy = { a: 1, b: 2 } (new object!)\n\n// Modify copy:\ncopy.a = 99;\n\n// Original unchanged (primitives copied by value):\nobj.a;  // 1 ‚úÖ\ncopy.a; // 99\n```\n\n**Why primitives don't affect original:**\n```javascript\n// Primitives are copied by VALUE:\nconst original = { num: 10 };\nconst copy = Object.assign({}, original);\n\ncopy.num = 999;\n\noriginal.num;  // 10 ‚úÖ (unchanged)\ncopy.num;      // 999 (separate value)\n```\n\n**Object.assign() syntax:**\n```javascript\n// Pattern: Object.assign(target, source1, source2, ...)\n\n// Create new copy:\nconst copy = Object.assign({}, obj);\n\n// Merge into existing object:\nconst target = { a: 1 };\nObject.assign(target, { b: 2 });\n// target now: { a: 1, b: 2 }\n\n// Merge multiple sources:\nconst merged = Object.assign({}, obj1, obj2, obj3);\n```\n\n**Memory trick:** Object.assign = copy primitives by value, objects by reference!",
    tags: ['objects', 'object-methods', 'copying'],
  },

{
    id: 'js-265',
    question: "üìù What's the output?\n\n```javascript\nconst obj = { a: 1 };\nObject.freeze(obj);\n\nobj.a = 99;\nobj.b = 2;\n\nconsole.log(obj);\n```",
    category: 'javascript',
    subcategory: 'object-methods',
    difficulty: 'medium',
    options: [
      '{a: 99, b: 2}',
      '{a: 1, b: 2}',
      '{a: 1}',
      'Error',
    ],
    correctAnswer: 2,
    explanation: "**Object.freeze() makes objects completely immutable** - no changes allowed, period!\n\n**Think of freeze() like encasing an object in ice** - you can see it, but you can't modify it in any way!\n\n**What happens:**\n```javascript\nconst obj = { a: 1 };\nObject.freeze(obj);\n\n// Try to modify existing property:\nobj.a = 99;\n// Fails silently! obj.a still 1\n\n// Try to add new property:\nobj.b = 2;\n// Fails silently! obj.b still undefined\n\nconsole.log(obj);\n// {a: 1} ‚úÖ (completely unchanged)\n```\n\n**What freeze() prevents:**\n```javascript\nconst frozen = Object.freeze({ x: 10 });\n\n// ‚ùå Can't modify existing properties:\nfrozen.x = 99;  // Fails\n\n// ‚ùå Can't add new properties:\nfrozen.y = 20;  // Fails\n\n// ‚ùå Can't delete properties:\ndelete frozen.x;  // Fails\n\n// ‚úÖ Can read properties:\nfrozen.x;  // 10 (reading works!)\n```\n\n**Strict mode throws errors:**\n```javascript\n'use strict';\nconst obj = Object.freeze({ a: 1 });\n\nobj.a = 99;  // ‚ùå TypeError!\n// \"Cannot assign to read only property\"\n\n// Non-strict mode: fails silently\n```\n\n**freeze() is shallow:**\n```javascript\nconst obj = Object.freeze({\n  a: 1,\n  nested: { b: 2 }\n});\n\nobj.a = 99;  // ‚ùå Fails\nobj.nested.b = 99;  // ‚úÖ Works! (nested object not frozen)\n```\n\n**Memory trick:** freeze = ice, completely immutable, no changes allowed!",
    tags: ['objects', 'object-methods', 'immutability'],
  },

{
    id: 'js-266',
    question: "üìù What's the difference between freeze() and seal()?\n\n```javascript\nconst frozen = Object.freeze({ a: 1 });\nconst sealed = Object.seal({ a: 1 });\n\nfrozen.a = 99;\nsealed.a = 99;\n\nfrozen.b = 2;\nsealed.b = 2;\n```",
    category: 'javascript',
    subcategory: 'object-methods',
    difficulty: 'hard',
    options: [
      'frozen: {a: 1}, sealed: {a: 1}',
      'frozen: {a: 99, b: 2}, sealed: {a: 99, b: 2}',
      'frozen: {a: 1}, sealed: {a: 99}',
      'frozen: {a: 99}, sealed: {a: 1}',
    ],
    correctAnswer: 2,
    explanation: "**freeze() = totally immutable, seal() = can modify but not add/delete** - different levels of protection!\n\n**Think of freeze() like a museum display case** (can't touch anything) and **seal() like a filled container** (can change contents, but can't add more compartments)!\n\n**What happens:**\n```javascript\nconst frozen = Object.freeze({ a: 1 });\nconst sealed = Object.seal({ a: 1 });\n\n// Try to modify existing property:\nfrozen.a = 99;  // ‚ùå Fails\nsealed.a = 99;  // ‚úÖ Works!\n\n// Try to add new property:\nfrozen.b = 2;  // ‚ùå Fails\nsealed.b = 2;  // ‚ùå Fails\n\n// Results:\nfrozen;  // {a: 1} ‚úÖ\nsealed;  // {a: 99} ‚úÖ\n```\n\n**Comparison table:**\n```javascript\nconst obj = { x: 1 };\n\n// FREEZE:\nObject.freeze(obj);\nobj.x = 99;     // ‚ùå Can't modify\nobj.y = 2;      // ‚ùå Can't add\ndelete obj.x;   // ‚ùå Can't delete\n\n// SEAL:\nObject.seal(obj);\nobj.x = 99;     // ‚úÖ Can modify!\nobj.y = 2;      // ‚ùå Can't add\ndelete obj.x;   // ‚ùå Can't delete\n```\n\n**Step-by-step execution:**\n```javascript\n// Step 1: Create objects\nconst frozen = Object.freeze({ a: 1 });\nconst sealed = Object.seal({ a: 1 });\n\n// Step 2: Modify existing properties\nfrozen.a = 99;\n// frozen.a ‚Üí still 1 (freeze blocks)\n\nsealed.a = 99;\n// sealed.a ‚Üí now 99 ‚úÖ (seal allows)\n\n// Step 3: Add new properties\nfrozen.b = 2;\n// frozen.b ‚Üí undefined (freeze blocks)\n\nsealed.b = 2;\n// sealed.b ‚Üí undefined (seal blocks)\n\n// Final state:\nfrozen;  // {a: 1}\nsealed;  // {a: 99}\n```\n\n**Use cases:**\n```javascript\n// freeze: Immutable constants\nconst CONFIG = Object.freeze({\n  API_URL: 'https://api.com',\n  MAX_RETRIES: 3\n});\nCONFIG.API_URL = 'hacked';  // ‚ùå Fails\n\n// seal: Fixed structure, mutable values\nconst user = Object.seal({\n  name: 'John',\n  age: 30\n});\nuser.age = 31;       // ‚úÖ Works\nuser.email = 'x@y';  // ‚ùå Fails\n```\n\n**Memory trick:** freeze = everything locked, seal = structure locked, values flexible!",
    tags: ['objects', 'object-methods', 'immutability'],
  },

{
    id: 'js-267',
    question: "üìù What's the output?\n\n```javascript\nconst obj = Object.create({ a: 1 });\nobj.b = 2;\n\nconsole.log(obj.a);\nconsole.log(obj.hasOwnProperty('a'));\nconsole.log(obj.hasOwnProperty('b'));\n```",
    category: 'javascript',
    subcategory: 'object-methods',
    difficulty: 'medium',
    options: [
      '1, true, true',
      '1, false, true',
      'undefined, false, true',
      '1, true, false',
    ],
    correctAnswer: 1,
    explanation: "**Object.create() sets the prototype** - properties can be inherited (not own) or own!\n\n**Think of Object.create() like inheriting traits** - you can access your parent's traits (prototype), but they're not YOUR traits (own properties)!\n\n**What happens:**\n```javascript\nconst obj = Object.create({ a: 1 });\n// obj.__proto__ = { a: 1 }\n// obj itself is empty: {}\n\nobj.b = 2;\n// obj now has own property: { b: 2 }\n// Still inherits a from prototype\n\n// Access a (inherited):\nobj.a;  // 1 ‚úÖ (found in prototype)\n\n// Check if a is own property:\nobj.hasOwnProperty('a');  // false ‚úÖ (inherited!)\n\n// Check if b is own property:\nobj.hasOwnProperty('b');  // true ‚úÖ (own!)\n```\n\n**Prototype vs own properties:**\n```javascript\n// Create object with prototype:\nconst obj = Object.create({ x: 10 });\n\n// Own property:\nobj.y = 20;\n\n// Property lookup:\nobj.x;  // 10 (found in prototype chain)\nobj.y;  // 20 (found as own property)\n\n// hasOwnProperty() checks ONLY own properties:\nobj.hasOwnProperty('x');  // false (inherited)\nobj.hasOwnProperty('y');  // true (own)\n```\n\n**Visual representation:**\n```javascript\nconst obj = Object.create({ a: 1 });\nobj.b = 2;\n\n// Structure:\n// obj = { b: 2 }\n//   |\n//   ‚îî‚îÄ> __proto__ = { a: 1 }\n\n// Accessing obj.a:\n// 1. Check obj's own properties? No 'a'\n// 2. Check obj's prototype? Yes! 'a': 1 ‚úÖ\n\n// Accessing obj.b:\n// 1. Check obj's own properties? Yes! 'b': 2 ‚úÖ\n```\n\n**hasOwnProperty() vs 'in' operator:**\n```javascript\nconst obj = Object.create({ a: 1 });\nobj.b = 2;\n\n// hasOwnProperty: own properties only\nobj.hasOwnProperty('a');  // false\nobj.hasOwnProperty('b');  // true\n\n// 'in' operator: own + inherited\n'a' in obj;  // true (found in prototype)\n'b' in obj;  // true (own property)\n```\n\n**Memory trick:** Object.create = set prototype, inherited ‚â† own property!",
    tags: ['objects', 'object-methods', 'prototypes'],
  },

{
    id: 'js-268',
    question: "üìù What's the output?\n\n```javascript\nconst obj1 = { a: 1, b: { c: 2 } };\nconst obj2 = Object.assign({}, obj1);\n\nobj2.b.c = 99;\nconsole.log(obj1.b.c);\n```",
    category: 'javascript',
    subcategory: 'object-methods',
    difficulty: 'hard',
    options: [
      '2',
      '99',
      'undefined',
      'Error',
    ],
    correctAnswer: 1,
    explanation: "**Object.assign() is SHALLOW** - nested objects are copied by reference, not by value!\n\n**Think of shallow copy like copying a document with sticky notes** - the text is duplicated, but both copies have sticky notes pointing to the SAME shared board!\n\n**What happens:**\n```javascript\nconst obj1 = { a: 1, b: { c: 2 } };\nconst obj2 = Object.assign({}, obj1);\n\n// obj1 and obj2 are different objects:\nobj1 !== obj2;  // true ‚úÖ\n\n// But nested object is SAME reference:\nobj1.b === obj2.b;  // true ‚ö†Ô∏è\n\n// Modify nested object through obj2:\nobj2.b.c = 99;\n\n// obj1 affected too (shared reference!):\nobj1.b.c;  // 99 ‚úÖ\n```\n\n**Why nested objects are shared:**\n```javascript\nconst obj1 = {\n  a: 1,           // Primitive (copied by value)\n  b: { c: 2 }     // Object (copied by reference!)\n};\n\nconst obj2 = Object.assign({}, obj1);\n\n// What gets copied:\n// obj2.a = 1 (NEW primitive, independent)\n// obj2.b = reference to obj1.b (SAME object!)\n\n// Memory layout:\n// obj1.b ‚îÄ‚îÄ‚îê\n//          ‚îú‚îÄ‚îÄ> { c: 2 }\n// obj2.b ‚îÄ‚îÄ‚îò\n// Both point to same object!\n```\n\n**Step-by-step:**\n```javascript\n// Step 1: Create original\nconst obj1 = { a: 1, b: { c: 2 } };\n\n// Step 2: Shallow copy\nconst obj2 = Object.assign({}, obj1);\n// obj2 = {\n//   a: 1,              // New primitive\n//   b: <ref to obj1.b> // Same reference!\n// }\n\n// Step 3: Modify nested object\nobj2.b.c = 99;\n// Since obj1.b and obj2.b are same object:\n// Both see the change!\n\n// Step 4: Check obj1\nobj1.b.c;  // 99 ‚úÖ (affected!)\n```\n\n**Deep copy solution:**\n```javascript\n// Problem: Shallow copy\nconst obj1 = { a: 1, b: { c: 2 } };\nconst shallow = Object.assign({}, obj1);\nshallow.b.c = 99;\nobj1.b.c;  // 99 ‚ùå (affected!)\n\n// Solution 1: JSON (simple cases)\nconst deep1 = JSON.parse(JSON.stringify(obj1));\ndeep1.b.c = 99;\nobj1.b.c;  // 2 ‚úÖ (unaffected!)\n\n// Solution 2: structuredClone (modern)\nconst deep2 = structuredClone(obj1);\ndeep2.b.c = 99;\nobj1.b.c;  // 2 ‚úÖ (unaffected!)\n```\n\n**When shallow copy is fine:**\n```javascript\n// All primitives - shallow copy works perfectly:\nconst user = { name: 'John', age: 30, active: true };\nconst copy = Object.assign({}, user);\n\ncopy.age = 31;\nuser.age;  // 30 ‚úÖ (unaffected)\n```\n\n**Memory trick:** Shallow copy = top level only, nested objects shared!",
    tags: ['objects', 'object-methods', 'shallow-copy', 'references'],
  },

{
    id: 'js-269',
    question: "üìù What's the output?\n\n```javascript\nconst obj = { a: 1, b: 2, c: 3 };\nconst entries = Object.entries(obj);\n\nconsole.log(entries);\n```",
    category: 'javascript',
    subcategory: 'object-methods',
    difficulty: 'easy',
    options: [
      "[['a', 1], ['b', 2], ['c', 3]]",
      "{a: 1, b: 2, c: 3}",
      "['a', 'b', 'c']",
      "[1, 2, 3]",
    ],
    correctAnswer: 0,
    explanation: "**Object.entries() converts object to array of [key, value] pairs** - perfect for iteration!\n\n**Think of Object.entries() like unzipping a backpack** - each item comes out paired with its label!\n\n**What happens:**\n```javascript\nconst obj = { a: 1, b: 2, c: 3 };\n\nObject.entries(obj);\n// [\n//   ['a', 1],  // Each entry is [key, value]\n//   ['b', 2],\n//   ['c', 3]\n// ] ‚úÖ\n```\n\n**Perfect for iteration:**\n```javascript\nconst user = { name: 'John', age: 30, city: 'NYC' };\n\n// Loop over entries:\nfor (const [key, value] of Object.entries(user)) {\n  console.log(`${key}: ${value}`);\n}\n// Output:\n// name: John\n// age: 30\n// city: NYC\n```\n\n**Object methods comparison:**\n```javascript\nconst obj = { x: 10, y: 20, z: 30 };\n\n// Object.keys() - array of keys:\nObject.keys(obj);\n// ['x', 'y', 'z']\n\n// Object.values() - array of values:\nObject.values(obj);\n// [10, 20, 30]\n\n// Object.entries() - array of [key, value]:\nObject.entries(obj);\n// [['x', 10], ['y', 20], ['z', 30]]\n```\n\n**Converting back to object:**\n```javascript\nconst entries = [['a', 1], ['b', 2], ['c', 3]];\n\n// Object.fromEntries() - reverse of entries():\nconst obj = Object.fromEntries(entries);\n// { a: 1, b: 2, c: 3 } ‚úÖ\n```\n\n**Practical use cases:**\n```javascript\n// Filter object properties:\nconst user = { name: 'John', age: 30, password: 'secret' };\n\nconst safe = Object.fromEntries(\n  Object.entries(user).filter(([key]) => key !== 'password')\n);\n// { name: 'John', age: 30 }\n\n// Transform values:\nconst prices = { apple: 1, banana: 2 };\n\nconst doubled = Object.fromEntries(\n  Object.entries(prices).map(([key, val]) => [key, val * 2])\n);\n// { apple: 2, banana: 4 }\n```\n\n**Memory trick:** entries = array of [key, value] pairs, great for loops!",
    tags: ['objects', 'object-methods'],
  },

{
    id: 'js-270',
    question: "üìù What's the output?\n\n```javascript\nconst obj = Object.create(null);\nobj.a = 1;\n\nconsole.log(obj.toString);\nconsole.log(obj.hasOwnProperty);\n```",
    category: 'javascript',
    subcategory: 'object-methods',
    difficulty: 'hard',
    options: [
      'function and function',
      'undefined and undefined',
      'function and undefined',
      'undefined and function',
    ],
    correctAnswer: 1,
    explanation: "**Object.create(null) creates a truly empty object** - no prototype, no inherited methods!\n\n**Think of Object.create(null) like a blank canvas** - regular objects come with pre-printed guides (inherited methods), but this one is COMPLETELY blank!\n\n**What happens:**\n```javascript\nconst obj = Object.create(null);\nobj.a = 1;\n\n// No prototype chain:\nobj.toString;        // undefined ‚úÖ\nobj.hasOwnProperty;  // undefined ‚úÖ\nobj.valueOf;         // undefined ‚úÖ\n// No inherited methods at all!\n```\n\n**Regular object vs null prototype:**\n```javascript\n// Regular object (has prototype):\nconst regular = {};\nregular.toString;        // function ‚úÖ\nregular.hasOwnProperty;  // function ‚úÖ\n// Inherits from Object.prototype\n\n// Null prototype object:\nconst nullProto = Object.create(null);\nnullProto.toString;        // undefined ‚ùå\nnullProto.hasOwnProperty;  // undefined ‚ùå\n// No prototype chain!\n```\n\n**Why this matters:**\n```javascript\n// Regular object has hidden properties:\nconst obj1 = {};\nfor (const key in obj1) {\n  // Nothing printed (no own properties)\n}\nobj1.toString;  // function (inherited!)\n\n// Null prototype object is TRULY empty:\nconst obj2 = Object.create(null);\nfor (const key in obj2) {\n  // Nothing printed (no properties at all)\n}\nobj2.toString;  // undefined (nothing inherited!)\n```\n\n**Use cases - safe dictionaries:**\n```javascript\n// Problem: Regular objects have inherited properties\nconst dict = {};\ndict['toString'];  // function (inherited!)\n// Could conflict with data!\n\n// Solution: Null prototype object\nconst safeDict = Object.create(null);\nsafeDict['toString'] = 'my value';  // ‚úÖ Safe!\nsafeDict['toString'];  // 'my value' (no conflict)\n```\n\n**Prototype chain visualization:**\n```javascript\n// Regular object:\nconst obj1 = { a: 1 };\n// obj1 ‚îÄ‚îÄ> Object.prototype ‚îÄ‚îÄ> null\n//          (toString, etc.)\n\n// Object.create(null):\nconst obj2 = Object.create(null);\nobj2.a = 1;\n// obj2 ‚îÄ‚îÄ> null\n//          (no prototype!)\n```\n\n**Working without hasOwnProperty:**\n```javascript\nconst obj = Object.create(null);\nobj.a = 1;\n\n// Can't use obj.hasOwnProperty:\nobj.hasOwnProperty('a');  // ‚ùå TypeError!\n\n// Use Object.prototype.hasOwnProperty.call():\nObject.prototype.hasOwnProperty.call(obj, 'a');  // true ‚úÖ\n\n// Or Object.hasOwn() (modern):\nObject.hasOwn(obj, 'a');  // true ‚úÖ\n```\n\n**Memory trick:** Object.create(null) = no prototype, truly empty, no inherited methods!",
    tags: ['objects', 'object-methods', 'prototypes'],
  },

{
    id: 'js-271',
    question: "üìù What's the output?\n\n```javascript\nconst target = { a: 1, b: 2 };\nconst source = { b: 3, c: 4 };\n\nObject.assign(target, source);\nconsole.log(target);\n```",
    category: 'javascript',
    subcategory: 'object-methods',
    difficulty: 'medium',
    options: [
      '{a: 1, b: 2}',
      '{a: 1, b: 3, c: 4}',
      '{b: 3, c: 4}',
      '{a: 1, b: 2, c: 4}',
    ],
    correctAnswer: 1,
    explanation: "**Object.assign() merges objects** - later sources overwrite earlier ones!\n\n**Think of Object.assign() like stacking transparent overlays** - properties from each layer show through, but overlapping ones get replaced by the top layer!\n\n**What happens:**\n```javascript\nconst target = { a: 1, b: 2 };\nconst source = { b: 3, c: 4 };\n\nObject.assign(target, source);\n// Merges source into target:\n// - a: 1 (unchanged, only in target)\n// - b: 3 (overwritten by source!)\n// - c: 4 (added from source)\n\ntarget;  // {a: 1, b: 3, c: 4} ‚úÖ\n```\n\n**Object.assign() mutates target:**\n```javascript\nconst target = { a: 1, b: 2 };\nconst source = { b: 3, c: 4 };\n\nconst result = Object.assign(target, source);\n\n// target is MODIFIED:\ntarget;  // {a: 1, b: 3, c: 4}\n\n// result references same object:\nresult === target;  // true ‚úÖ\n```\n\n**Merge without mutating:**\n```javascript\nconst obj1 = { a: 1, b: 2 };\nconst obj2 = { b: 3, c: 4 };\n\n// Pass empty object as target:\nconst merged = Object.assign({}, obj1, obj2);\n// merged: {a: 1, b: 3, c: 4}\n\n// Original objects unchanged:\nobj1;  // {a: 1, b: 2} ‚úÖ\nobj2;  // {b: 3, c: 4} ‚úÖ\n```\n\n**Multiple sources:**\n```javascript\nconst a = { x: 1 };\nconst b = { y: 2 };\nconst c = { z: 3, x: 99 };\n\nconst merged = Object.assign({}, a, b, c);\n// Process order: {} ‚Üí a ‚Üí b ‚Üí c\n// x: 1 (from a), then 99 (from c, overwrites!)\n// y: 2 (from b)\n// z: 3 (from c)\n\nmerged;  // {x: 99, y: 2, z: 3} ‚úÖ\n```\n\n**Common pattern - spread operator:**\n```javascript\n// Object.assign():\nconst merged1 = Object.assign({}, obj1, obj2);\n\n// Spread operator (equivalent):\nconst merged2 = { ...obj1, ...obj2 };\n\n// Both produce same result!\n```\n\n**Memory trick:** Object.assign = merge into target, later sources win!",
    tags: ['objects', 'object-methods'],
  },

{
    id: 'js-272',
    question: "üìù What's the output?\n\n```javascript\nconst obj = {};\nObject.defineProperty(obj, 'a', {\n  value: 42,\n  writable: false\n});\n\nobj.a = 99;\nconsole.log(obj.a);\n```",
    category: 'javascript',
    subcategory: 'object-methods',
    difficulty: 'hard',
    options: [
      '99',
      '42',
      'undefined',
      'Error',
    ],
    correctAnswer: 1,
    explanation: "**Object.defineProperty() creates properties with precise control** - writable: false makes them read-only!\n\n**Think of defineProperty() like setting file permissions** - you can make files read-only, executable, or hidden!\n\n**What happens:**\n```javascript\nconst obj = {};\nObject.defineProperty(obj, 'a', {\n  value: 42,\n  writable: false  // Read-only!\n});\n\n// Try to modify:\nobj.a = 99;\n// Fails silently in non-strict mode\n\nobj.a;  // 42 ‚úÖ (unchanged)\n```\n\n**Property descriptors:**\n```javascript\nObject.defineProperty(obj, 'prop', {\n  value: 10,           // The value\n  writable: false,     // Can't be changed\n  enumerable: true,    // Shows in for...in loops\n  configurable: false  // Can't be deleted or reconfigured\n});\n\n// Defaults (if not specified):\n// writable: false\n// enumerable: false\n// configurable: false\n```\n\n**writable: false behavior:**\n```javascript\nconst obj = {};\nObject.defineProperty(obj, 'readonly', {\n  value: 100,\n  writable: false\n});\n\n// Non-strict mode:\nobj.readonly = 999;  // Fails silently\nobj.readonly;  // 100 (unchanged)\n\n// Strict mode:\n'use strict';\nobj.readonly = 999;  // ‚ùå TypeError!\n// \"Cannot assign to read only property\"\n```\n\n**Regular assignment vs defineProperty:**\n```javascript\n// Regular assignment:\nobj.x = 1;\n// Equivalent to:\nObject.defineProperty(obj, 'x', {\n  value: 1,\n  writable: true,      // ‚úÖ Can change\n  enumerable: true,    // ‚úÖ Shows in loops\n  configurable: true   // ‚úÖ Can delete\n});\n\n// defineProperty (defaults):\nObject.defineProperty(obj, 'y', { value: 2 });\n// Equivalent to:\n{\n  value: 2,\n  writable: false,     // ‚ùå Read-only!\n  enumerable: false,   // ‚ùå Hidden in loops\n  configurable: false  // ‚ùå Can't delete\n}\n```\n\n**Descriptor properties:**\n```javascript\nconst obj = {};\n\n// enumerable controls for...in visibility:\nObject.defineProperty(obj, 'hidden', {\n  value: 1,\n  enumerable: false  // Won't show in loops\n});\n\nfor (const key in obj) {\n  // 'hidden' not included\n}\n\n// configurable controls delete and reconfiguration:\nObject.defineProperty(obj, 'permanent', {\n  value: 2,\n  configurable: false  // Can't delete or redefine\n});\n\ndelete obj.permanent;  // Fails\n```\n\n**Memory trick:** defineProperty = precise control, writable:false = read-only!",
    tags: ['objects', 'object-methods', 'descriptors'],
  },

{
    id: 'js-273',
    question: "üìù What's the output?\n\n```javascript\nconst obj = { a: 1 };\nconst prop = 'a';\n\nconsole.log(prop in obj);\nconsole.log(obj.hasOwnProperty(prop));\n```",
    category: 'javascript',
    subcategory: 'object-methods',
    difficulty: 'medium',
    options: [
      'true and true',
      'false and false',
      'true and false',
      'false and true',
    ],
    correctAnswer: 0,
    explanation: "**'in' operator checks entire chain, hasOwnProperty() checks own only** - both true for own properties!\n\n**Think of 'in' like asking 'do you have access to this?'** and **hasOwnProperty() like 'is this YOURS?'** - you might have access to your parent's car, but it's not YOUR car!\n\n**What happens:**\n```javascript\nconst obj = { a: 1 };\nconst prop = 'a';\n\n// 'in' checks property anywhere (own + inherited):\nprop in obj;  // true ‚úÖ\n\n// hasOwnProperty checks own properties only:\nobj.hasOwnProperty(prop);  // true ‚úÖ\n\n// Both true because 'a' is OWN property!\n```\n\n**Difference with inherited properties:**\n```javascript\nconst obj = { x: 1 };\n\n// Check inherited property:\n'toString' in obj;  // true ‚úÖ (inherited from Object.prototype)\nobj.hasOwnProperty('toString');  // false ‚ùå (not own!)\n\n// Check own property:\n'x' in obj;  // true ‚úÖ (own property)\nobj.hasOwnProperty('x');  // true ‚úÖ (own property)\n```\n\n**Prototype chain example:**\n```javascript\nconst parent = { a: 1 };\nconst child = Object.create(parent);\nchild.b = 2;\n\n// child structure:\n// child = { b: 2 }\n//   ‚îî‚îÄ> prototype: { a: 1 }\n\n// Property 'a' (inherited):\n'a' in child;  // true ‚úÖ (found in prototype)\nchild.hasOwnProperty('a');  // false ‚ùå (inherited, not own)\n\n// Property 'b' (own):\n'b' in child;  // true ‚úÖ (own property)\nchild.hasOwnProperty('b');  // true ‚úÖ (own property)\n```\n\n**Comparison table:**\n```javascript\nconst obj = Object.create({ inherited: 1 });\nobj.own = 2;\n\n// Check 'own':\n'own' in obj;                // true ‚úÖ\nobj.hasOwnProperty('own');   // true ‚úÖ\n\n// Check 'inherited':\n'inherited' in obj;                // true ‚úÖ (in chain)\nobj.hasOwnProperty('inherited');   // false ‚ùå (not own)\n\n// Check non-existent:\n'missing' in obj;                // false ‚ùå\nobj.hasOwnProperty('missing');   // false ‚ùå\n```\n\n**Use cases:**\n```javascript\n// 'in' - check if accessible (own or inherited):\nif ('toString' in obj) {\n  obj.toString();  // Safe to call\n}\n\n// hasOwnProperty - check if truly owned:\nfor (const key in obj) {\n  if (obj.hasOwnProperty(key)) {\n    // Only process own properties, skip inherited\n  }\n}\n```\n\n**Memory trick:** 'in' = anywhere in chain, hasOwnProperty = own properties only!",
    tags: ['objects', 'object-methods', 'operators'],
  },

{
    id: 'js-274',
    question: "üìù What's the output?\n\n```javascript\nconst obj = { a: 1, b: 2 };\nObject.preventExtensions(obj);\n\nobj.c = 3;\nobj.a = 99;\ndelete obj.b;\n\nconsole.log(obj);\n```",
    category: 'javascript',
    subcategory: 'object-methods',
    difficulty: 'hard',
    options: [
      '{a: 99, b: 2}',
      '{a: 1}',
      '{a: 99}',
      '{a: 1, b: 2}',
    ],
    correctAnswer: 2,
    explanation: "**Object.preventExtensions() prevents NEW properties** - but existing ones can be modified or deleted!\n\n**Think of preventExtensions() like a full parking lot** - no new cars can enter, but the ones already there can leave or move around!\n\n**What happens:**\n```javascript\nconst obj = { a: 1, b: 2 };\nObject.preventExtensions(obj);\n\n// Try to add new property:\nobj.c = 3;\n// ‚ùå Fails (can't add new properties)\n\n// Modify existing property:\nobj.a = 99;\n// ‚úÖ Works! (can modify existing)\n\n// Delete existing property:\ndelete obj.b;\n// ‚úÖ Works! (can delete existing)\n\nobj;  // {a: 99} ‚úÖ\n```\n\n**Three levels of object protection:**\n```javascript\nconst obj = { x: 1, y: 2 };\n\n// 1. preventExtensions - can't ADD:\nObject.preventExtensions(obj);\nobj.z = 3;      // ‚ùå Can't add\nobj.x = 99;     // ‚úÖ Can modify\ndelete obj.y;   // ‚úÖ Can delete\n\n// 2. seal - can't ADD or DELETE:\nObject.seal(obj);\nobj.z = 3;      // ‚ùå Can't add\nobj.x = 99;     // ‚úÖ Can modify\ndelete obj.y;   // ‚ùå Can't delete\n\n// 3. freeze - can't do ANYTHING:\nObject.freeze(obj);\nobj.z = 3;      // ‚ùå Can't add\nobj.x = 99;     // ‚ùå Can't modify\ndelete obj.y;   // ‚ùå Can't delete\n```\n\n**Step-by-step execution:**\n```javascript\nconst obj = { a: 1, b: 2 };\nObject.preventExtensions(obj);\n\n// Step 1: Try adding c\nobj.c = 3;\n// Fails silently (non-strict mode)\n// obj = { a: 1, b: 2 }\n\n// Step 2: Modify a\nobj.a = 99;\n// Works!\n// obj = { a: 99, b: 2 }\n\n// Step 3: Delete b\ndelete obj.b;\n// Works!\n// obj = { a: 99 } ‚úÖ\n```\n\n**Checking extensibility:**\n```javascript\nconst obj = { a: 1 };\n\n// Before:\nObject.isExtensible(obj);  // true ‚úÖ\n\nObject.preventExtensions(obj);\n\n// After:\nObject.isExtensible(obj);  // false ‚ùå\n```\n\n**Strict mode behavior:**\n```javascript\n'use strict';\nconst obj = { a: 1 };\nObject.preventExtensions(obj);\n\nobj.b = 2;  // ‚ùå TypeError!\n// \"Cannot add property b, object is not extensible\"\n\n// Non-strict mode: fails silently\n```\n\n**Comparison summary:**\n```javascript\n//                        Add    Modify  Delete\n// preventExtensions:     ‚ùå      ‚úÖ      ‚úÖ\n// seal:                  ‚ùå      ‚úÖ      ‚ùå\n// freeze:                ‚ùå      ‚ùå      ‚ùå\n```\n\n**Memory trick:** preventExtensions = no new properties, existing ones flexible!",
    tags: ['objects', 'object-methods', 'immutability'],
  },
];
