import { QuizQuestion } from '../../types/quiz';

export const thisQuizzes: QuizQuestion[] = [
{
    id: 'js-054',
    question: "ðŸ–¥ï¸ What's the output?\n\n```javascript\nconst person = { name: \"Lydia\" };\n\nfunction sayHi(age) {\n  return `${this.name} is ${age}`;\n}\n\nconsole.log(sayHi.call(person, 21));\nconsole.log(sayHi.bind(person, 21));\n```",
    category: 'javascript',
    subcategory: 'this',
    difficulty: 'medium',
    options: [
          "undefined is 21 Lydia is 21",
          "function function",
          "Lydia is 21 Lydia is 21",
          "Lydia is 21 function"
    ],
    correctAnswer: 3,
    explanation: "`.call()` vs `.bind()` is like **calling a taxi NOW** vs **scheduling a taxi for later** - both get you where you need to go, but the timing is completely different!\n\n**Think of it like ordering food:**\n- `.call()`: \"I want pizza RIGHT NOW!\" â†’ Pizza arrives immediately\n- `.bind()`: \"Give me a coupon to order pizza later\" â†’ You get a coupon, no pizza yet\n\n**The key difference: `.call()` executes immediately, `.bind()` returns a function for later**\n\n**What's happening:**\n\n```javascript\nconst person = { name: \"Lydia\" };\n\nfunction sayHi(age) {\n  return `${this.name} is ${age}`;\n}\n\nconsole.log(sayHi.call(person, 21));   // Executes NOW\nconsole.log(sayHi.bind(person, 21));   // Returns a function\n```\n\n**Step-by-step execution:**\n\n**Line 1: `.call()` execution**\n```javascript\nsayHi.call(person, 21)\nâ†“\n1. Set this = person\n2. Call function IMMEDIATELY with age = 21\n3. Return \"Lydia is 21\"\nâ†“\nconsole.log(\"Lydia is 21\")\n```\n\n**Line 2: `.bind()` execution**\n```javascript\nsayHi.bind(person, 21)\nâ†“\n1. Set this = person\n2. Pre-fill age = 21\n3. Return a NEW function (not executed yet!)\nâ†“\nconsole.log([Function: bound sayHi])\n```\n\n**Final output:**\n```\nLydia is 21\nfunction\n```\n\n**Visual representation:**\n\n```javascript\n// .call() - Execute immediately\nsayHi.call(person, 21)\n  â†“ Sets this to person\n  â†“ Calls function right now\n  â†“ Returns: \"Lydia is 21\"\n\n// .bind() - Return bound function\nsayHi.bind(person, 21)\n  â†“ Sets this to person\n  â†“ Pre-fills arguments\n  â†“ Returns: [Function] (not executed!)\n```\n\n**How to actually use `.bind()`:**\n\n```javascript\n// .bind() returns a function, so you need to call it\nconst boundFunc = sayHi.bind(person, 21);\nconsole.log(boundFunc());  // NOW it executes â†’ \"Lydia is 21\"\n\n// Or call it immediately:\nconsole.log(sayHi.bind(person, 21)());  // \"Lydia is 21\"\n//                                  â†‘â†‘ Extra parentheses to execute\n```\n\n**Complete comparison:**\n\n**`.call(thisArg, arg1, arg2, ...)`**\n```javascript\nconst person = { name: \"Lydia\" };\n\nfunction greet(age, city) {\n  return `${this.name} is ${age} from ${city}`;\n}\n\nconst result = greet.call(person, 21, \"NYC\");\nconsole.log(result);  // \"Lydia is 21 from NYC\"\n// Executes immediately, returns the result\n```\n\n**`.bind(thisArg, arg1, arg2, ...)`**\n```javascript\nconst person = { name: \"Lydia\" };\n\nfunction greet(age, city) {\n  return `${this.name} is ${age} from ${city}`;\n}\n\nconst boundGreet = greet.bind(person, 21, \"NYC\");\nconsole.log(boundGreet);  // [Function: bound greet]\nconsole.log(boundGreet());  // \"Lydia is 21 from NYC\"\n// Returns a function, must call it to execute\n```\n\n**Partial application with `.bind()`:**\n\n```javascript\nfunction greet(greeting, age, city) {\n  return `${greeting}! ${this.name} is ${age} from ${city}`;\n}\n\nconst person = { name: \"Lydia\" };\n\n// Pre-fill some arguments\nconst sayHello = greet.bind(person, \"Hello\");\n\nconsole.log(sayHello(21, \"NYC\"));     // \"Hello! Lydia is 21 from NYC\"\nconsole.log(sayHello(25, \"LA\"));      // \"Hello! Lydia is 25 from LA\"\nconsole.log(sayHello(30, \"Miami\"));   // \"Hello! Lydia is 30 from Miami\"\n\n// this and \"Hello\" are locked in!\n```\n\n**Real-world use cases:**\n\n**1. Event listeners (`.bind()` is perfect)**\n```javascript\nclass Counter {\n  constructor() {\n    this.count = 0;\n  }\n  \n  increment() {\n    this.count++;\n    console.log(this.count);\n  }\n}\n\nconst counter = new Counter();\n\n// âŒ Wrong: loses context\nbutton.addEventListener('click', counter.increment);\n// this will be the button, not counter!\n\n// âœ… Correct: bind preserves context\nbutton.addEventListener('click', counter.increment.bind(counter));\n// Now this is always counter\n```\n\n**2. Borrowing methods (`.call()` is perfect)**\n```javascript\nconst person1 = {\n  name: \"Lydia\",\n  greet(age) {\n    console.log(`Hi, I'm ${this.name}, ${age} years old`);\n  }\n};\n\nconst person2 = { name: \"John\" };\n\n// Borrow person1's greet method for person2\nperson1.greet.call(person2, 30);  // \"Hi, I'm John, 30 years old\"\n```\n\n**3. Array methods on array-like objects**\n```javascript\nfunction showArgs() {\n  // 'arguments' is array-like but not an array\n  console.log(arguments);  // { '0': 'a', '1': 'b', '2': 'c' }\n  \n  // Borrow Array.prototype.slice using .call()\n  const argsArray = Array.prototype.slice.call(arguments);\n  console.log(argsArray);  // ['a', 'b', 'c'] - real array!\n}\n\nshowArgs('a', 'b', 'c');\n```\n\n**Also available: `.apply()`**\n\n```javascript\n// .apply() is like .call() but takes an array of arguments\nfunction greet(greeting, age, city) {\n  return `${greeting}! ${this.name} is ${age} from ${city}`;\n}\n\nconst person = { name: \"Lydia\" };\n\n// .call() - arguments as separate values\ngreet.call(person, \"Hello\", 21, \"NYC\");\n\n// .apply() - arguments as an array\ngreet.apply(person, [\"Hello\", 21, \"NYC\"]);\n\n// Both return: \"Hello! Lydia is 21 from NYC\"\n```\n\n**Summary table:**\n\n| Method | Executes? | Returns | Arguments | When to use |\n|--------|-----------|---------|-----------|-------------|\n| `.call()` | âœ“ Immediately | Result | Separate | One-time call with known args |\n| `.apply()` | âœ“ Immediately | Result | Array | One-time call with array args |\n| `.bind()` | âœ— Later | Function | Separate | Event handlers, callbacks, partial application |\n\n**Chaining `.bind()` multiple times:**\n\n```javascript\nfunction greet(greeting, age) {\n  return `${greeting}! ${this.name} is ${age}`;\n}\n\nconst person = { name: \"Lydia\" };\n\n// First bind sets 'this' and 'greeting'\nconst boundOnce = greet.bind(person, \"Hello\");\n\n// Second bind tries to change 'this' - but it's locked!\nconst anotherPerson = { name: \"John\" };\nconst boundTwice = boundOnce.bind(anotherPerson);\n\nconsole.log(boundTwice(21));  // \"Hello! Lydia is 21\"\n// Still uses Lydia! Once bound, 'this' is permanent\n```\n\n**Common mistake - logging bound function:**\n\n```javascript\n// âŒ Wrong:\nconsole.log(sayHi.bind(person, 21));\n// Logs: [Function: bound sayHi] (the function itself)\n\n// âœ… Correct - call the bound function:\nconsole.log(sayHi.bind(person, 21)());\n// Logs: \"Lydia is 21\" (the result)\n\n// âœ… Or store and call later:\nconst bound = sayHi.bind(person, 21);\nconsole.log(bound());  // \"Lydia is 21\"\n```\n\n**Arrow functions don't have `.bind()`:**\n\n```javascript\nconst person = { name: \"Lydia\" };\n\nconst sayHi = (age) => {\n  return `${this.name} is ${age}`;\n};\n\n// Arrow function's 'this' is lexically bound\n// .bind() won't change it!\nconst bound = sayHi.bind(person);\nconsole.log(bound(21));  // Won't work as expected\n// 'this' is captured from surrounding scope, not 'person'\n```\n\n**Modern alternative: Arrow functions**\n\n```javascript\nclass Counter {\n  constructor() {\n    this.count = 0;\n  }\n  \n  // Old way: need .bind()\n  increment() {\n    this.count++;\n  }\n  \n  // New way: arrow function captures 'this' automatically\n  incrementArrow = () => {\n    this.count++;\n  }\n}\n\nconst counter = new Counter();\n\n// Old: needs .bind()\nbutton.addEventListener('click', counter.increment.bind(counter));\n\n// New: no .bind() needed!\nbutton.addEventListener('click', counter.incrementArrow);\n```\n\n**Memory tricks:**\n- `.call()` = \"Call RIGHT NOW\" (immediate execution)\n- `.bind()` = \"Bind for later\" (returns function)\n- `.call(this, arg1, arg2)` - comma-separated arguments\n- `.apply(this, [arg1, arg2])` - array of arguments\n- `.bind()` perfect for callbacks and event handlers\n- `.call()` perfect for borrowing methods\n- Once bound, `this` is locked forever!",
    tags: ["javascript","quiz"],
  },

{
    id: 'js-059',
    question: "ðŸ“ What's the output?\n\n```javascript\nconst obj = {\n  value: 42,\n  getValue: function() {\n    return this.value;\n  }\n};\n\nconst getValue = obj.getValue;\nconsole.log(getValue());\n```",
    category: 'javascript',
    subcategory: 'this',
    difficulty: 'medium',
    options: [
          "undefined",
          "42",
          "ReferenceError",
          "TypeError"
    ],
    correctAnswer: 0,
    explanation: "Method extraction is like **photocopying a recipe but forgetting which kitchen it came from** - the instructions are the same, but you've lost the context of where to find the ingredients!\n\n**Think of it like a business card:**\n- On the object: \"Call me at THIS office\" (context is clear)\n- Extracted: \"Call me\" (wait, which number? Context lost!)\n\n**The key rule: Methods lose their `this` context when extracted from objects**\n\n**What's happening:**\n\n```javascript\nconst obj = {\n  value: 42,\n  getValue: function() {\n    return this.value;  // 'this' should be obj\n  }\n};\n\nconst getValue = obj.getValue;  // Extract the method\nconsole.log(getValue());         // Call it standalone\n```\n\n**Step-by-step execution:**\n\n**Step 1: Method extraction**\n```javascript\nconst getValue = obj.getValue;\nâ†“\ngetValue now holds the function:\nfunction() {\n  return this.value;\n}\n\nBUT it's disconnected from obj!\n```\n\n**Step 2: Standalone function call**\n```javascript\ngetValue()\nâ†“\nWhen called without an object:\n- 'this' = global object (window in browser)\n- Or 'this' = undefined (in strict mode)\nâ†“\nthis.value = undefined (global object has no 'value' property)\nâ†“\nReturns: undefined\n```\n\n**Final output:**\n```\nundefined\n```\n\n**Visual representation:**\n\n```javascript\n// On the object - 'this' is clear:\nobj.getValue()\n  â†“ this = obj\n  â†“ this.value = 42\n  â†“ Returns: 42 âœ“\n\n// Extracted method - 'this' is lost:\nconst getValue = obj.getValue\ngetValue()\n  â†“ this = global/undefined\n  â†“ this.value = undefined\n  â†“ Returns: undefined âœ—\n```\n\n**How JavaScript determines `this`:**\n\n**Rule: `this` is determined by HOW the function is called, not WHERE it's defined**\n\n```javascript\nconst obj = {\n  value: 42,\n  getValue() {\n    return this.value;\n  }\n};\n\n// 1. Called as method: this = obj\nobj.getValue();  // 42 âœ“\n\n// 2. Called as function: this = global/undefined\nconst fn = obj.getValue;\nfn();  // undefined âœ—\n\n// 3. Called with .call(): this = whatever you pass\nfn.call(obj);  // 42 âœ“\nfn.call({ value: 100 });  // 100 âœ“\n```\n\n**Real-world example - setTimeout problem:**\n\n```javascript\nconst user = {\n  name: \"Alice\",\n  greet() {\n    console.log(`Hello, ${this.name}!`);\n  }\n};\n\n// âŒ Wrong: passes extracted method\nsetTimeout(user.greet, 1000);\n// After 1 second: \"Hello, undefined!\"\n// this is lost because setTimeout calls it as a regular function\n```\n\n**Solutions to preserve context:**\n\n**Solution 1: Use an arrow function wrapper**\n```javascript\nsetTimeout(() => user.greet(), 1000);\n// Arrow function preserves context\n// Calls user.greet() as a method\n// Logs: \"Hello, Alice!\" âœ“\n```\n\n**Solution 2: Use `.bind()`**\n```javascript\nsetTimeout(user.greet.bind(user), 1000);\n// .bind() locks 'this' to user\n// Logs: \"Hello, Alice!\" âœ“\n```\n\n**Solution 3: Store reference**\n```javascript\nconst greet = user.greet.bind(user);\nsetTimeout(greet, 1000);\n// Logs: \"Hello, Alice!\" âœ“\n```\n\n**Solution 4: Use arrow function in object (class fields)**\n```javascript\nclass User {\n  constructor(name) {\n    this.name = name;\n  }\n  \n  // Arrow function captures 'this' from constructor\n  greet = () => {\n    console.log(`Hello, ${this.name}!`);\n  }\n}\n\nconst user = new User(\"Alice\");\nsetTimeout(user.greet, 1000);  // \"Hello, Alice!\" âœ“\n// Arrow functions don't lose context!\n```\n\n**Why this happens - the four rules of `this`:**\n\n**1. Method call: `this` = object before the dot**\n```javascript\nobj.getValue();  // this = obj\nuser.greet();    // this = user\n```\n\n**2. Function call: `this` = global object (or undefined in strict mode)**\n```javascript\ngetValue();  // this = window/global/undefined\ngreet();     // this = window/global/undefined\n```\n\n**3. Constructor call: `this` = new object**\n```javascript\nnew User(\"Alice\");  // this = newly created User instance\n```\n\n**4. Explicit call: `this` = whatever you specify**\n```javascript\ngetValue.call(obj);       // this = obj\ngetValue.apply(obj);      // this = obj\ngetValue.bind(obj)();     // this = obj\n```\n\n**Common scenarios where context is lost:**\n\n**1. Event listeners**\n```javascript\nconst button = document.querySelector('button');\n\nconst counter = {\n  count: 0,\n  increment() {\n    this.count++;\n    console.log(this.count);\n  }\n};\n\n// âŒ Wrong: loses context\nbutton.addEventListener('click', counter.increment);\n// this will be the button, not counter!\n\n// âœ… Correct: preserve context\nbutton.addEventListener('click', () => counter.increment());\n// or\nbutton.addEventListener('click', counter.increment.bind(counter));\n```\n\n**2. Array methods**\n```javascript\nconst obj = {\n  multiplier: 2,\n  multiply(num) {\n    return num * this.multiplier;\n  }\n};\n\nconst numbers = [1, 2, 3];\n\n// âŒ Wrong: loses context\nnumbers.map(obj.multiply);\n// [NaN, NaN, NaN] - this.multiplier is undefined\n\n// âœ… Correct: preserve context\nnumbers.map(num => obj.multiply(num));\n// or\nnumbers.map(obj.multiply.bind(obj));\n// or\nnumbers.map(obj.multiply, obj);  // 'thisArg' parameter\n// All return: [2, 4, 6] âœ“\n```\n\n**3. Callbacks**\n```javascript\nconst api = {\n  baseUrl: 'https://api.example.com',\n  fetch(endpoint, callback) {\n    const url = `${this.baseUrl}/${endpoint}`;\n    // ...\n    callback(data);\n  }\n};\n\nconst handler = {\n  onData(data) {\n    console.log(`Received:`, data);\n    console.log(`Handler:`, this);  // What is 'this'?\n  }\n};\n\n// âŒ Wrong:\napi.fetch('users', handler.onData);\n// 'this' in onData will be undefined/global\n\n// âœ… Correct:\napi.fetch('users', data => handler.onData(data));\n// or\napi.fetch('users', handler.onData.bind(handler));\n```\n\n**Strict mode vs non-strict mode:**\n\n```javascript\n// Non-strict mode:\nfunction showThis() {\n  console.log(this);\n}\n\nshowThis();  // Window/global object\n\n// Strict mode:\n'use strict';\nfunction showThis() {\n  console.log(this);\n}\n\nshowThis();  // undefined\n\n// Extracted method:\nconst obj = {\n  value: 42,\n  getValue() {\n    console.log(this);\n  }\n};\n\nconst fn = obj.getValue;\nfn();  \n// Non-strict: Window/global\n// Strict: undefined\n```\n\n**Comparison: regular function vs arrow function:**\n\n**Regular function - dynamic `this`:**\n```javascript\nconst obj = {\n  value: 42,\n  getValue: function() {\n    return this.value;  // 'this' depends on how it's called\n  }\n};\n\nobj.getValue();         // 42 (this = obj)\nconst fn = obj.getValue;\nfn();                   // undefined (this = global/undefined)\n```\n\n**Arrow function - lexical `this`:**\n```javascript\nconst obj = {\n  value: 42,\n  getValue: () => {\n    return this.value;  // 'this' captured from surrounding scope\n  }\n};\n\nobj.getValue();         // undefined (this = global scope)\nconst fn = obj.getValue;\nfn();                   // undefined (still global scope)\n\n// Arrow functions can't be used as methods!\n// 'this' is always from the surrounding scope\n```\n\n**Proper use of arrow functions:**\n```javascript\nconst obj = {\n  value: 42,\n  getValue() {  // Regular function for the method\n    // Arrow function inside captures 'this' from getValue\n    setTimeout(() => {\n      console.log(this.value);  // 'this' = obj (captured!)\n    }, 1000);\n  }\n};\n\nobj.getValue();  // After 1 second: 42 âœ“\n```\n\n**Memory tricks:**\n- Extracted methods = photocopies without context\n- `this` determined by HOW function is called, not WHERE defined\n- Method call (`obj.method()`) â†’ `this` = obj\n- Function call (`method()`) â†’ `this` = global/undefined\n- Use `.bind()`, arrow wrappers, or arrow function fields to preserve context\n- Arrow functions capture `this` lexically (from surrounding scope)\n- When in doubt, use arrow function wrappers: `() => obj.method()`",
    tags: ["functions","this","context","methods"],
  },

{
    id: 'js-088',
    question: "ðŸ“ What will happen?\n\n```javascript\nlet config = {\n  alert: setInterval(() => {\n    console.log(\"Alert!\");\n  }, 1000),\n};\n\nconfig = null;\n```",
    category: 'javascript',
    subcategory: 'this',
    difficulty: 'medium',
    options: [
          "The setInterval callback won't be invoked",
          "The setInterval callback gets invoked once",
          "The setInterval callback will still be called every second",
          "We never invoked config.alert(), config is null"
    ],
    correctAnswer: 2,
    explanation: "Normally when we set objects equal to `null`, those objects get _garbage collected_ as there is no reference anymore to that object. However, since the callback function within `setInterval` is an arrow function (thus bound to the `config` object), the callback function still holds a reference to the `config` object.\nAs long as there is a reference, the object won't get garbage collected.\nSince this is an interval, setting `config` to `null` or `delete`-ing `config.alert` won't garbage-collect the interval, so the interval will still be called.\nIt should be cleared with `clearInterval(config.alert)` to remove it from memory.\nSince it was not cleared, the `setInterval` callback function will still get invoked every 1000ms (1s).",
    tags: ["javascript","quiz"],
  },

{
    id: 'js-094',
    question: "ðŸ–¥ï¸ What's the output?\n\n```javascript\nconst animals = {};\nlet dog = { emoji: \"ðŸ¶\" };\nlet cat = { emoji: \"ðŸˆ\" };\n\nanimals[dog] = { ...dog, name: \"Mara\" };\nanimals[cat] = { ...cat, name: \"Sara\" };\n\nconsole.log(animals[dog]);\n```",
    category: 'javascript',
    subcategory: 'this',
    difficulty: 'medium',
    options: [
          "{ emoji: \"ðŸ¶\", name: \"Mara\" }",
          "{ emoji: \"ðŸˆ\", name: \"Sara\" }",
          "undefined",
          "ReferenceError"
    ],
    correctAnswer: 1,
    explanation: "Object keys are converted to strings.\n\nSince the value of `dog` is an object, `animals[dog]` actually means that weâ€™re creating a new property called `\"[object Object]\"` equal to the new object. `animals[\"[object Object]\"]` is now equal to `{ emoji: \"ðŸ¶\", name: \"Mara\"}`.\n\n`cat` is also an object, which means that `animals[cat]` actually means that weâ€™re overwriting the value of `animals[\"[object Object]\"]` with the new cat properties.\n\nLogging `animals[dog]`, or actually `animals[\"[object Object]\"]` since converting the `dog` object to a string results `\"[object Object]\"`, returns the `{ emoji: \"ðŸˆ\", name: \"Sara\" }`.",
    tags: ["javascript","quiz"],
  },

{
    id: 'js-126',
    question: "ðŸ“ What's the output?\n\n```javascript\n[1, 2, 3, 4].reduce((x, y) => console.log(x, y));\n```",
    category: 'javascript',
    subcategory: 'this',
    difficulty: 'medium',
    options: [
          "1 2 and 3 3 and 6 4",
          "1 2 and 2 3 and 3 4",
          "1 undefined and 2 undefined and 3 undefined and 4 undefined",
          "1 2 and undefined 3 and undefined 4"
    ],
    correctAnswer: 3,
    explanation: "The first argument that the `reduce` method receives is the _accumulator_, `x` in this case. The second argument is the _current value_, `y`. With the reduce method, we execute a callback function on every element in the array, which could ultimately result in one single value.\n\nIn this example, we are not returning any values, we are simply logging the values of the accumulator and the current value.\n\nThe value of the accumulator is equal to the previously returned value of the callback function. If you don't pass the optional `initialValue` argument to the `reduce` method, the accumulator is equal to the first element on the first call.\n\nOn the first call, the accumulator (`x`) is `1`, and the current value (`y`) is `2`. We don't return from the callback function, we log the accumulator, and the current values: `1` and `2` get logged.\n\nIf you don't return a value from a function, it returns `undefined`. On the next call, the accumulator is `undefined`, and the current value is `3`. `undefined` and `3` get logged.\n\nOn the fourth call, we again don't return from the callback function. The accumulator is again `undefined`, and the current value is `4`. `undefined` and `4` get logged.",
    tags: ["javascript","quiz"],
  },

{
    id: 'js-206',
    question: "ðŸ“ What's the output?\n\n```javascript\nfunction Person(name) {\n  this.name = name;\n  this.sayHi = function() {\n    setTimeout(function() {\n      console.log(this.name);\n    }, 100);\n  };\n}\n\nconst person = new Person('John');\nperson.sayHi();\n```",
    category: 'javascript',
    subcategory: 'this',
    difficulty: 'hard',
    options: [
      "'John'",
      "undefined",
      "Error",
      "null",
    ],
    correctAnswer: 1,
    explanation: "`this` in setTimeout is like **leaving a note for someone but forgetting to sign it** - when they read it later, they don't know who wrote it!\n\n**Think of it like a delayed phone call:**\n- Regular function in setTimeout: \"Who's calling?\" \"Uh... I forgot!\" (loses context)\n- Arrow function in setTimeout: \"It's me, John!\" (remembers context)\n\n**The key rule: Regular functions in setTimeout lose their `this` context**\n\n**What's happening:**\n\n```javascript\nfunction Person(name) {\n  this.name = name;\n  this.sayHi = function() {\n    setTimeout(function() {\n      console.log(this.name);  // What is 'this' here?\n    }, 100);\n  };\n}\n\nconst person = new Person('John');\nperson.sayHi();\n```\n\n**Step-by-step execution:**\n\n**Step 1: Create person instance**\n```javascript\nconst person = new Person('John');\nâ†“\nperson = {\n  name: 'John',\n  sayHi: function() { ... }\n}\n```\n\n**Step 2: Call sayHi()**\n```javascript\nperson.sayHi();\nâ†“\nInside sayHi():\n  this = person âœ“\n  this.name = 'John' âœ“\n```\n\n**Step 3: Schedule setTimeout**\n```javascript\nsetTimeout(function() {\n  console.log(this.name);\n}, 100);\nâ†“\nCallback function is extracted and scheduled\nBUT 'this' context is NOT preserved!\n```\n\n**Step 4: After 100ms - callback executes**\n```javascript\nfunction() {\n  console.log(this.name);\n}\nâ†“\nsetTimeout calls this as a regular function\nâ†“\nthis = global object (or undefined in strict mode)\nâ†“\nthis.name = undefined\nâ†“\nLogs: undefined\n```\n\n**Final output:**\n```\nundefined\n```\n\n**Visual timeline:**\n\n```\n0ms: person.sayHi() called\n     Inside sayHi: this = person âœ“\n     \n0ms: setTimeout scheduled\n     Callback function = function() { console.log(this.name) }\n     Context is NOT captured!\n     \n100ms: setTimeout fires\n       Calls callback as regular function\n       this = global/undefined âœ—\n       this.name = undefined\n       Logs: undefined\n```\n\n**Why this happens:**\n\nWhen `setTimeout` calls the callback, it calls it like this:\n```javascript\ncallback();  // Regular function call!\n```\n\nNot like this:\n```javascript\nperson.callback();  // Method call\n```\n\nRegular function calls â†’ `this` = global/undefined!\n\n**Solutions - 4 ways to fix it:**\n\n**Solution 1: Use arrow function (BEST)**\n```javascript\nfunction Person(name) {\n  this.name = name;\n  this.sayHi = function() {\n    setTimeout(() => {\n      console.log(this.name);  // Arrow function captures 'this'!\n    }, 100);\n  };\n}\n\nconst person = new Person('John');\nperson.sayHi();  // After 100ms: \"John\" âœ“\n```\n\n**Solution 2: Use `.bind(this)`**\n```javascript\nfunction Person(name) {\n  this.name = name;\n  this.sayHi = function() {\n    setTimeout(function() {\n      console.log(this.name);\n    }.bind(this), 100);  // Bind 'this' to the callback\n  };\n}\n\nconst person = new Person('John');\nperson.sayHi();  // After 100ms: \"John\" âœ“\n```\n\n**Solution 3: Store `this` in a variable**\n```javascript\nfunction Person(name) {\n  this.name = name;\n  this.sayHi = function() {\n    const self = this;  // Store reference\n    setTimeout(function() {\n      console.log(self.name);  // Use stored reference\n    }, 100);\n  };\n}\n\nconst person = new Person('John');\nperson.sayHi();  // After 100ms: \"John\" âœ“\n```\n\n**Solution 4: Pass parameter to callback**\n```javascript\nfunction Person(name) {\n  this.name = name;\n  this.sayHi = function() {\n    setTimeout((name) => {\n      console.log(name);\n    }, 100, this.name);  // Pass name as argument\n  };\n}\n\nconst person = new Person('John');\nperson.sayHi();  // After 100ms: \"John\" âœ“\n```\n\n**How arrow functions solve this:**\n\nArrow functions don't have their own `this` - they **capture** `this` from their surrounding scope!\n\n```javascript\nfunction Person(name) {\n  this.name = name;  // this = person instance\n  \n  this.sayHi = function() {\n    // Inside sayHi: this = person instance\n    \n    setTimeout(() => {\n      // Arrow function captures 'this' from sayHi\n      // this still = person instance! âœ“\n      console.log(this.name);\n    }, 100);\n  };\n}\n```\n\n**Comparison: Regular function vs Arrow function**\n\n**Regular function (own `this`):**\n```javascript\nthis.sayHi = function() {\n  // this = person âœ“\n  \n  setTimeout(function() {\n    // New 'this' context!\n    // this = global/undefined âœ—\n    console.log(this.name);  // undefined\n  }, 100);\n};\n```\n\n**Arrow function (captures `this`):**\n```javascript\nthis.sayHi = function() {\n  // this = person âœ“\n  \n  setTimeout(() => {\n    // Captures 'this' from sayHi\n    // this = person âœ“\n    console.log(this.name);  // \"John\"\n  }, 100);\n};\n```\n\n**Real-world examples:**\n\n**1. Event handlers with timers**\n```javascript\nclass Button {\n  constructor(label) {\n    this.label = label;\n    this.clickCount = 0;\n  }\n  \n  handleClick() {\n    this.clickCount++;\n    \n    // âŒ Wrong: loses context\n    setTimeout(function() {\n      console.log(`${this.label}: ${this.clickCount}`);\n      // \"undefined: undefined\"\n    }, 1000);\n    \n    // âœ… Correct: arrow function\n    setTimeout(() => {\n      console.log(`${this.label}: ${this.clickCount}`);\n      // \"Submit: 1\" âœ“\n    }, 1000);\n  }\n}\n\nconst btn = new Button('Submit');\nbtn.handleClick();\n```\n\n**2. Animation loops**\n```javascript\nclass Sprite {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n  \n  animate() {\n    // âŒ Wrong\n    setInterval(function() {\n      this.x += 1;  // Error! 'this' is undefined\n      this.y += 1;\n    }, 16);\n    \n    // âœ… Correct\n    setInterval(() => {\n      this.x += 1;  // Works! 'this' is Sprite instance\n      this.y += 1;\n    }, 16);\n  }\n}\n\nconst sprite = new Sprite(0, 0);\nsprite.animate();\n```\n\n**3. Debouncing with setTimeout**\n```javascript\nclass SearchBox {\n  constructor() {\n    this.query = '';\n  }\n  \n  search(text) {\n    this.query = text;\n    \n    // Debounce: wait 300ms before searching\n    clearTimeout(this.timer);\n    \n    // âŒ Wrong: loses context\n    this.timer = setTimeout(function() {\n      this.performSearch(this.query);  // Error!\n    }, 300);\n    \n    // âœ… Correct: arrow function\n    this.timer = setTimeout(() => {\n      this.performSearch(this.query);  // Works!\n    }, 300);\n  }\n  \n  performSearch(query) {\n    console.log('Searching for:', query);\n  }\n}\n```\n\n**The `self = this` pattern (old-school fix):**\n\n```javascript\n// Common in older code before arrow functions\nfunction Person(name) {\n  this.name = name;\n  \n  this.sayHi = function() {\n    var self = this;  // Capture 'this' in a closure variable\n    \n    setTimeout(function() {\n      console.log(self.name);  // Use captured reference\n    }, 100);\n  };\n}\n\n// Common variable names: self, that, _this, me\n```\n\n**Modern class syntax:**\n\n```javascript\nclass Person {\n  constructor(name) {\n    this.name = name;\n  }\n  \n  sayHi() {\n    setTimeout(() => {\n      console.log(this.name);  // Arrow function captures 'this'\n    }, 100);\n  }\n}\n\nconst person = new Person('John');\nperson.sayHi();  // \"John\" âœ“\n```\n\n**Class field with arrow function (auto-bound):**\n\n```javascript\nclass Person {\n  constructor(name) {\n    this.name = name;\n  }\n  \n  // Arrow function field - automatically bound!\n  sayHi = () => {\n    setTimeout(() => {\n      console.log(this.name);\n    }, 100);\n  }\n}\n\nconst person = new Person('John');\n\n// Can extract without losing context!\nconst sayHi = person.sayHi;\nsayHi();  // Still works! âœ“\n```\n\n**Common mistake - mixing regular and arrow functions:**\n\n```javascript\n// âŒ Wrong: arrow function for method\nfunction Person(name) {\n  this.name = name;\n  \n  this.sayHi = () => {  // Arrow function as method\n    // 'this' captured from surrounding scope\n    // If this is global scope â†’ 'this' = window/undefined\n    console.log(this.name);  // undefined\n  };\n}\n\n// âœ… Correct: regular function for method, arrow for callback\nfunction Person(name) {\n  this.name = name;\n  \n  this.sayHi = function() {  // Regular function for method\n    setTimeout(() => {        // Arrow for callback\n      console.log(this.name);\n    }, 100);\n  };\n}\n```\n\n**Memory tricks:**\n- setTimeout callbacks = functions called later, context gets lost\n- Arrow functions capture `this` from surrounding scope (lexical)\n- Regular functions get new `this` based on how they're called\n- Use arrow functions for callbacks/timers inside methods\n- Use regular functions for the methods themselves\n- Old pattern: `const self = this` (before arrow functions existed)\n- Modern pattern: Always use arrow functions for async callbacks!",
    tags: ['javascript', 'quiz'],
  }
];
