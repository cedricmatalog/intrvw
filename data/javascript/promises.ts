import { QuizQuestion } from '../../types/quiz';

export const promisesQuizzes: QuizQuestion[] = [
{
    id: 'js-070',
    question: "‚ö° What kind of information would get logged?\n\n```javascript\nfetch(\"https://www.website.com/api/user/1\")\n  .then((res) => res.json())\n  .then((res) => console.log(res));\n```",
    category: 'javascript',
    subcategory: 'promises',
    difficulty: 'medium',
    options: [
          "The result of the fetch method.",
          "The result of the second invocation of the fetch method.",
          "The result of the callback in the previous .then().",
          "It would always be undefined."
    ],
    correctAnswer: 2,
    explanation: "Promise chaining is like an **assembly line** - each `.then()` receives the output from the previous step and can transform it before passing it along!\n\n**Think of it like a restaurant order:**\n1. Waiter takes your order (fetch)\n2. Kitchen prepares it (first .then)\n3. Waiter brings it to you (second .then)\n4. You eat it (console.log)\n\n**What's happening step-by-step:**\n\n```javascript\nfetch(\"https://www.website.com/api/user/1\")\n  .then((res) => res.json())        // Step 1: Parse Response\n  .then((res) => console.log(res)); // Step 2: Use parsed data\n```\n\n**Line 1: `fetch()`** ‚Üí Returns **Promise<Response>**\n```javascript\nfetch(\"https://www.website.com/api/user/1\")\n‚Üì\nMakes HTTP request\n‚Üì\nReturns: Promise that resolves to Response object\n```\n\n**Line 2: First `.then()`** ‚Üí Transforms Response to JSON\n```javascript\n.then((res) => res.json())\n‚Üì\nReceives: Response object (headers, status, body, etc.)\n‚Üì\nCalls: res.json() which returns Promise<ParsedData>\n‚Üì\nReturns: The parsed JSON data (user object)\n```\n\n**Line 3: Second `.then()`** ‚Üí Uses the parsed data\n```javascript\n.then((res) => console.log(res))\n‚Üì\nReceives: The RETURN VALUE from previous .then()\n         Which is the parsed JSON: { id: 1, name: \"John\", ... }\n‚Üì\nLogs: The actual user data object\n```\n\n**The key rule: Each `.then()` receives what the previous `.then()` RETURNED**\n\n```javascript\nPromise.resolve(5)\n  .then(x => x * 2)        // receives 5, returns 10\n  .then(x => x + 3)        // receives 10, returns 13\n  .then(x => console.log(x)); // receives 13, logs 13\n```\n\n**Visualizing the chain:**\n```javascript\nfetch(url)\n  ‚Üì returns Promise<Response>\n.then((res) => res.json())\n  ‚Üì returns Promise<UserData>\n.then((res) => console.log(res))\n  ‚Üì logs UserData: { id: 1, name: \"John\", email: \"john@example.com\" }\n```\n\n**What `res.json()` returns:**\n- `res.json()` is also async and returns a Promise\n- When you return a Promise from `.then()`, the next `.then()` waits for it\n- The next `.then()` receives the RESOLVED value, not the Promise itself\n\n**Real-world example with different transformations:**\n```javascript\nfetch(\"https://api.example.com/user/1\")\n  .then(res => {\n    console.log(\"Got response!\", res.status); // 200\n    return res.json(); // Return parsed data\n  })\n  .then(userData => {\n    console.log(\"Got user!\", userData.name); // \"John\"\n    return userData.id; // Return just the ID\n  })\n  .then(userId => {\n    console.log(\"User ID:\", userId); // 1\n    return fetch(`https://api.example.com/user/${userId}/posts`);\n  })\n  .then(res => res.json())\n  .then(posts => {\n    console.log(\"User's posts:\", posts); // Array of posts\n  });\n```\n\n**Common mistake - forgetting to return:**\n```javascript\n// ‚ùå Wrong:\nfetch(url)\n  .then(res => {\n    res.json(); // Forgot to return!\n  })\n  .then(data => {\n    console.log(data); // undefined!\n  });\n\n// ‚úÖ Correct:\nfetch(url)\n  .then(res => res.json()) // Returns the Promise\n  .then(data => {\n    console.log(data); // The parsed data ‚úì\n  });\n```\n\n**What if you don't return anything?**\n```javascript\nPromise.resolve(5)\n  .then(x => {\n    x * 2; // No return statement!\n  })\n  .then(x => {\n    console.log(x); // undefined (nothing was returned)\n  });\n```\n\n**Returning different types:**\n```javascript\nPromise.resolve(5)\n  .then(x => x * 2)              // Return a value ‚Üí next .then gets 10\n  .then(x => Promise.resolve(x)) // Return a Promise ‚Üí next .then waits and gets resolved value\n  .then(x => {\n    console.log(x);               // Return nothing ‚Üí next .then gets undefined\n  })\n  .then(x => console.log(x));    // undefined\n```\n\n**Memory tricks:**\n- `.then()` is like a conveyor belt - passes value forward\n- Each `.then()` receives what the previous one RETURNED\n- If you return a Promise, the next `.then()` waits and gets the resolved value\n- No return = next `.then()` gets undefined\n- `res.json()` returns a Promise with the parsed data\n\n**Why this matters:**\nThis pattern allows you to break complex async operations into clear, sequential steps, making code more readable and maintainable.",
    tags: ["javascript","quiz"],
  },

{
    id: 'js-153',
    question: "ü§ù What does this return?\n\n```javascript\nconst firstPromise = new Promise((res, rej) => {\n  setTimeout(res, 500, \"one\");\n});\n\nconst secondPromise = new Promise((res, rej) => {\n  setTimeout(res, 100, \"two\");\n});\n\nPromise.race([firstPromise, secondPromise]).then((res) => console.log(res));\n```",
    category: 'javascript',
    subcategory: 'promises',
    difficulty: 'medium',
    options: [
          "\"one\"",
          "\"two\"",
          "\"two\" \"one\"",
          "\"one\" \"two\""
    ],
    correctAnswer: 1,
    explanation: "`Promise.race()` is like a **sprint race** - the FIRST one to cross the finish line wins, and the others are ignored!\n\n**Think of it like a pizza delivery race:**\n- Two delivery drivers leave at the same time\n- Driver 1 takes 500ms (8 minutes)\n- Driver 2 takes 100ms (1 minute)\n- You only pay attention to whoever arrives FIRST\n- The slower one? You don't care anymore - you already have your pizza!\n\n**What's happening:**\n\n```javascript\nconst firstPromise = new Promise((res, rej) => {\n  setTimeout(res, 500, \"one\");  // Resolves after 500ms with \"one\"\n});\n\nconst secondPromise = new Promise((res, rej) => {\n  setTimeout(res, 100, \"two\");  // Resolves after 100ms with \"two\"\n});\n```\n\n**Timeline:**\n```\nTime 0ms:   Both promises start\n            firstPromise: \"I'll finish in 500ms!\"\n            secondPromise: \"I'll finish in 100ms!\"\n\nTime 100ms: secondPromise finishes ‚Üí \"two\"\n            Promise.race() immediately resolves with \"two\"\n            ‚úì Race is over!\n\nTime 500ms: firstPromise finishes ‚Üí \"one\"\n            But Promise.race() already finished!\n            This value is ignored.\n```\n\n**The key rule: First to finish wins, others are ignored**\n\n**Visual representation:**\n```javascript\nPromise.race([firstPromise, secondPromise])\n‚Üì\nBoth start running simultaneously\n‚Üì\n100ms passes ‚Üí secondPromise resolves with \"two\"\n‚Üì\nPromise.race() immediately resolves with \"two\"\n‚Üì\n.then((res) => console.log(res))\n‚Üì\nLogs: \"two\"\n\n// firstPromise still resolves at 500ms, but nobody's listening anymore!\n```\n\n**Real-world use cases:**\n\n**1. Timeout for slow operations:**\n```javascript\nconst timeout = new Promise((_, reject) => \n  setTimeout(() => reject('Request timed out!'), 5000)\n);\n\nconst fetchData = fetch('https://api.example.com/data');\n\nPromise.race([fetchData, timeout])\n  .then(data => console.log('Got data!', data))\n  .catch(err => console.log('Error:', err));\n// If fetch takes > 5 seconds, timeout wins and rejects!\n```\n\n**2. Try multiple servers, use the fastest:**\n```javascript\nconst server1 = fetch('https://backup1.api.com/data');\nconst server2 = fetch('https://backup2.api.com/data');\nconst server3 = fetch('https://backup3.api.com/data');\n\nPromise.race([server1, server2, server3])\n  .then(res => res.json())\n  .then(data => console.log('Got data from fastest server!', data));\n```\n\n**3. User clicks button, auto-proceed after timeout:**\n```javascript\nconst userClick = new Promise(resolve => {\n  button.addEventListener('click', () => resolve('user clicked'));\n});\n\nconst autoAdvance = new Promise(resolve => {\n  setTimeout(() => resolve('auto-advanced'), 10000);\n});\n\nPromise.race([userClick, autoAdvance])\n  .then(result => {\n    console.log(result); // Either 'user clicked' or 'auto-advanced'\n    goToNextPage();\n  });\n```\n\n**Comparison with other Promise combinators:**\n\n**`Promise.race()` - First to finish (resolve OR reject)**\n```javascript\nconst fast = Promise.resolve('fast');\nconst slow = Promise.resolve('slow');\n\nPromise.race([fast, slow]).then(console.log); // \"fast\"\n```\n\n**`Promise.all()` - Wait for ALL to resolve**\n```javascript\nconst p1 = Promise.resolve(1);\nconst p2 = Promise.resolve(2);\n\nPromise.all([p1, p2]).then(console.log); // [1, 2]\n// If ANY rejects, the whole thing rejects immediately\n```\n\n**`Promise.allSettled()` - Wait for ALL to finish (resolve or reject)**\n```javascript\nconst p1 = Promise.resolve(1);\nconst p2 = Promise.reject('error');\n\nPromise.allSettled([p1, p2]).then(console.log);\n// [\n//   { status: 'fulfilled', value: 1 },\n//   { status: 'rejected', reason: 'error' }\n// ]\n```\n\n**`Promise.any()` - First to RESOLVE (ignores rejections)**\n```javascript\nconst p1 = Promise.reject('fail');\nconst p2 = Promise.resolve('success');\n\nPromise.any([p1, p2]).then(console.log); // \"success\"\n// Only rejects if ALL promises reject\n```\n\n**What if the fastest one REJECTS?**\n```javascript\nconst fastFail = new Promise((_, rej) => \n  setTimeout(rej, 100, 'Error!')\n);\nconst slowSuccess = new Promise((res) => \n  setTimeout(res, 500, 'Success')\n);\n\nPromise.race([fastFail, slowSuccess])\n  .then(console.log)\n  .catch(console.error); // Logs: \"Error!\" (the first to finish)\n```\n\n**Common gotcha:**\n```javascript\n// The losing promises DON'T get cancelled!\nconst expensive = new Promise(res => {\n  // This expensive operation STILL completes\n  doExpensiveWork();\n  res('done');\n});\n\nconst timeout = new Promise(res => setTimeout(res, 100, 'timeout'));\n\nPromise.race([expensive, timeout]);\n// timeout wins, but expensive work continues in background!\n```\n\n**Memory tricks:**\n- `Promise.race()` = Sprint race - first to finish wins\n- Winner takes all - other results are ignored\n- Works with both resolve AND reject - whoever finishes first\n- Perfect for timeouts and fallbacks\n- Losing promises still execute (they're not cancelled!)",
    tags: ["javascript","quiz"],
  },

{
    id: 'js-154',
    question: "üñ•Ô∏è What's the output?\n\n```javascript\nasync function getData() {\n  return await Promise.resolve(\"I made it!\");\n}\n\nconst data = getData();\nconsole.log(data);\n```",
    category: 'javascript',
    subcategory: 'promises',
    difficulty: 'medium',
    options: [
          "\"I made it!\"",
          "Promise {<resolved>: \"I made it!\"}",
          "Promise {<pending>}",
          "undefined"
    ],
    correctAnswer: 2,
    explanation: "`async` functions are like **promise-wrapping machines** - they ALWAYS return a Promise, no matter what you return inside them!\n\n**Think of `async` like a gift-wrapping service:**\n- You give them something (any value)\n- They ALWAYS wrap it in a Promise box\n- Even if you give them a Promise, they wrap it in another Promise box\n- You can't unwrap it immediately - you have to wait!\n\n**What's happening:**\n\n```javascript\nasync function getData() {\n  return await Promise.resolve(\"I made it!\");  // Inside: \"I made it!\"\n}                                                // Outside: Promise!\n\nconst data = getData();  // Call the function\nconsole.log(data);       // What do we get?\n```\n\n**Step-by-step execution:**\n\n**Step 1: Call `getData()`**\n```javascript\nconst data = getData();\n‚Üì\nasync function is invoked\n‚Üì\nStarts executing, but immediately returns a Promise\n‚Üì\nThe Promise is in <pending> state\n‚Üì\ndata = Promise {<pending>}\n```\n\n**Step 2: Log immediately**\n```javascript\nconsole.log(data);\n‚Üì\nWe log BEFORE the Promise resolves!\n‚Üì\nLogs: Promise {<pending>}\n```\n\n**Step 3: Later, the Promise resolves**\n```javascript\n// After the microtask queue processes:\nPromise {<pending>} ‚Üí Promise {<fulfilled>: \"I made it!\"}\n// But we already logged!\n```\n\n**The key rule: `async` functions ALWAYS return a Promise immediately**\n\nEven if the inside finishes instantly, the Promise is still returned first!\n\n**Visual timeline:**\n```\n0ms: getData() called\n0ms: Returns Promise {<pending>} immediately\n0ms: data = Promise {<pending>}\n0ms: console.log(data) executes ‚Üí logs Promise {<pending>}\n\n1ms: Microtask queue processes\n1ms: Promise resolves with \"I made it!\"\n1ms: But we already logged!\n```\n\n**How to actually get the value:**\n\n**Option 1: Use `.then()`**\n```javascript\nconst data = getData();\ndata.then(res => console.log(res));  // \"I made it!\"\n```\n\n**Option 2: Use `await` (must be in async function)**\n```javascript\nasync function main() {\n  const data = await getData();  // Wait for it!\n  console.log(data);             // \"I made it!\"\n}\n\nmain();\n```\n\n**Option 3: Immediately await**\n```javascript\n(async () => {\n  console.log(await getData());  // \"I made it!\"\n})();\n```\n\n**What `async` does to your return value:**\n\n```javascript\n// Regular function:\nfunction regular() {\n  return \"hello\";  // Returns: \"hello\"\n}\nconst result = regular();  // \"hello\"\n\n// Async function:\nasync function asyncFn() {\n  return \"hello\";  // Returns: Promise {<fulfilled>: \"hello\"}\n}\nconst result = asyncFn();  // Promise {<pending>}\n```\n\n**`async` wraps EVERYTHING in a Promise:**\n\n```javascript\n// Returning a value:\nasync function getValue() {\n  return 42;\n}\ngetValue();  // Promise {<fulfilled>: 42}\n\n// Returning a Promise:\nasync function getPromise() {\n  return Promise.resolve(42);\n}\ngetPromise();  // Promise {<fulfilled>: 42} (not Promise<Promise>!)\n\n// Returning nothing:\nasync function getNothing() {\n  // No return statement\n}\ngetNothing();  // Promise {<fulfilled>: undefined}\n\n// Throwing an error:\nasync function getError() {\n  throw new Error('Oops!');\n}\ngetError();  // Promise {<rejected>: Error: Oops!}\n```\n\n**Common mistake:**\n```javascript\n// ‚ùå This doesn't work:\nconst data = getData();\nif (data === \"I made it!\") {  // false! data is a Promise\n  console.log('Success!');\n}\n\n// ‚úÖ This works:\nconst data = await getData();  // Must be in async function\nif (data === \"I made it!\") {   // true! data is the string\n  console.log('Success!');\n}\n```\n\n**Why does `await` exist inside if `async` returns immediately?**\n\n```javascript\nasync function process() {\n  console.log('Start');\n  \n  const result = await longOperation();  // Pause here!\n  // Function execution pauses, but Promise is returned immediately\n  \n  console.log('Got:', result);  // Resume here when ready\n  return result;\n}\n\nconst promise = process();\n// Promise returned immediately, but function body still executing!\n\nconsole.log('After call');\n// This logs BEFORE \"Got:\" because await pauses the function\n```\n\n**Output order:**\n```\nStart\nAfter call\nGot: [result]\n```\n\n**Real-world example:**\n```javascript\nasync function fetchUser(id) {\n  const response = await fetch(`/api/users/${id}`);\n  const data = await response.json();\n  return data;  // Returns Promise {<fulfilled>: userData}\n}\n\n// ‚ùå Wrong:\nconst user = fetchUser(1);\nconsole.log(user.name);  // Error! user is a Promise\n\n// ‚úÖ Correct:\nfetchUser(1).then(user => {\n  console.log(user.name);  // Works!\n});\n\n// ‚úÖ Or with await:\nasync function main() {\n  const user = await fetchUser(1);\n  console.log(user.name);  // Works!\n}\n```\n\n**Memory tricks:**\n- `async` = automatic Promise wrapper\n- `async` functions ALWAYS return immediately with a Promise\n- The Promise starts as `<pending>`\n- Use `.then()` or `await` to get the actual value\n- Can't unwrap Promises synchronously - must wait!",
    tags: ["javascript","quiz"],
  },

{
    id: 'js-155',
    question: "üñ•Ô∏è What's the value of output?\n\n```javascript\nconst myPromise = () => Promise.resolve(\"I have resolved!\");\n\nfunction firstFunction() {\n  myPromise().then((res) => console.log(res));\n  console.log(\"second\");\n}\n\nasync function secondFunction() {\n  console.log(await myPromise());\n  console.log(\"second\");\n}\n\nfirstFunction();\nsecondFunction();\n```",
    category: 'javascript',
    subcategory: 'promises',
    difficulty: 'medium',
    options: [
          "I have resolved!, second and I have resolved!, second",
          "second, I have resolved! and second, I have resolved!",
          "I have resolved!, second and second, I have resolved!",
          "second, I have resolved! and I have resolved!, second"
    ],
    correctAnswer: 3,
    explanation: "`.then()` vs `await` is like the difference between **setting a reminder** vs **stopping and waiting** - they both get the value, but handle timing completely differently!\n\n**Think of it like ordering food:**\n- `.then()`: \"Call me when it's ready, I'll keep doing other stuff\" üèÉ\n- `await`: \"I'll wait right here until you bring it\" üßç\n\n**The key difference: `.then()` doesn't pause, `await` does**\n\n**What happens in `firstFunction()` with `.then()`:**\n\n```javascript\nfunction firstFunction() {\n  myPromise().then((res) => console.log(res));  // Schedule for later\n  console.log(\"second\");                         // Run NOW\n}\n```\n\n**Execution flow:**\n```\n1. Call myPromise().then(...)\n   ‚Üí Registers callback in microtask queue\n   ‚Üí Function keeps running immediately!\n   \n2. console.log(\"second\")\n   ‚Üí Executes synchronously\n   ‚Üí Logs: \"second\"\n   \n3. Function finishes, call stack empties\n\n4. Microtask queue processes\n   ‚Üí .then() callback runs\n   ‚Üí Logs: \"I have resolved!\"\n```\n\n**What happens in `secondFunction()` with `await`:**\n\n```javascript\nasync function secondFunction() {\n  console.log(await myPromise());  // WAIT here!\n  console.log(\"second\");            // Can't run until above finishes\n}\n```\n\n**Execution flow:**\n```\n1. Reach await myPromise()\n   ‚Üí Function PAUSES here\n   ‚Üí Returns Promise to caller immediately\n   ‚Üí Waits for myPromise() to resolve\n   \n2. myPromise() resolves with \"I have resolved!\"\n   ‚Üí Function RESUMES\n   \n3. console.log(await myPromise())\n   ‚Üí Logs: \"I have resolved!\"\n   \n4. console.log(\"second\")\n   ‚Üí Logs: \"second\"\n```\n\n**Complete execution timeline:**\n\n```javascript\nfirstFunction();\nsecondFunction();\n```\n\n**Timeline:**\n```\n--- Synchronous Phase ---\n0ms: firstFunction() starts\n0ms:   - myPromise().then(...) registered (doesn't pause!)\n0ms:   - console.log(\"second\") runs ‚Üí logs: \"second\"\n0ms: firstFunction() finishes\n\n0ms: secondFunction() starts\n0ms:   - Reaches await myPromise()\n0ms:   - Function pauses, returns Promise\n0ms: secondFunction() call finishes (but function body still paused)\n\n--- Microtask Queue Phase ---\n1ms: Process microtasks\n1ms:   - secondFunction() resumes\n1ms:   - console.log(await myPromise()) ‚Üí logs: \"I have resolved!\"\n1ms:   - console.log(\"second\") ‚Üí logs: \"second\"\n\n2ms: Process next microtask\n2ms:   - firstFunction .then() callback runs\n2ms:   - console.log(res) ‚Üí logs: \"I have resolved!\"\n```\n\n**Final output order:**\n```\nsecond                  (from firstFunction - synchronous)\nI have resolved!        (from secondFunction - await)\nsecond                  (from secondFunction)\nI have resolved!        (from firstFunction - .then())\n```\n\n**Visual comparison:**\n\n**`.then()` - Non-blocking:**\n```javascript\nfunction firstFunction() {\n  myPromise().then((res) => console.log(res));\n  // ‚Üë Registers callback, keeps going ‚Üì\n  console.log(\"second\");  // Runs immediately\n}\n// Logs: second ‚Üí I have resolved!\n```\n\n**`await` - Blocking:**\n```javascript\nasync function secondFunction() {\n  console.log(await myPromise());\n  // ‚Üë PAUSES here until resolved ‚Üì\n  console.log(\"second\");  // Must wait\n}\n// Logs: I have resolved! ‚Üí second\n```\n\n**Real-world example:**\n\n```javascript\n// Making breakfast with .then() (multitasking)\nfunction makeBreakfastThen() {\n  toaster.toast().then(() => console.log('Toast ready!'));\n  // Don't wait! Start other tasks immediately\n  console.log('Making coffee...');\n  console.log('Setting table...');\n}\n// Output:\n// Making coffee...\n// Setting table...\n// Toast ready!\n\n// Making breakfast with await (one at a time)\nasync function makeBreakfastAwait() {\n  await toaster.toast();  // Wait for toast to finish\n  console.log('Toast ready!');\n  // Only NOW can we do other things\n  console.log('Making coffee...');\n  console.log('Setting table...');\n}\n// Output:\n// Toast ready!\n// Making coffee...\n// Setting table...\n```\n\n**Another key difference - error handling:**\n\n**With `.then()`:**\n```javascript\nfunction withThen() {\n  myPromise()\n    .then((res) => console.log(res))\n    .catch((err) => console.error(err));  // Must chain .catch()\n  \n  console.log('This runs immediately');\n}\n```\n\n**With `await`:**\n```javascript\nasync function withAwait() {\n  try {\n    const res = await myPromise();  // Can use try/catch\n    console.log(res);\n  } catch (err) {\n    console.error(err);\n  }\n  \n  console.log('This waits for promise to resolve');\n}\n```\n\n**Common gotcha - multiple awaits:**\n\n```javascript\n// ‚ùå Slow - runs sequentially (one at a time)\nasync function slow() {\n  const user = await fetchUser();      // Wait 1 second\n  const posts = await fetchPosts();    // Wait 1 second\n  const comments = await fetchComments(); // Wait 1 second\n  // Total: 3 seconds\n}\n\n// ‚úÖ Fast - runs in parallel\nasync function fast() {\n  const [user, posts, comments] = await Promise.all([\n    fetchUser(),\n    fetchPosts(),\n    fetchComments()\n  ]);\n  // Total: 1 second (all run at same time)\n}\n\n// ‚úÖ Also fast - .then() doesn't pause\nfunction fastThen() {\n  fetchUser().then(user => console.log(user));\n  fetchPosts().then(posts => console.log(posts));\n  fetchComments().then(comments => console.log(comments));\n  // All three start immediately!\n}\n```\n\n**When to use which:**\n\n**Use `.then()` when:**\n- You want code to continue running immediately\n- You're handling multiple independent async operations\n- You want to fire-and-forget\n\n**Use `await` when:**\n- You need the result before continuing\n- You want sequential, readable code\n- You need to use try/catch error handling\n- The next operation depends on the previous result\n\n**Memory tricks:**\n- `.then()` = \"Call me when ready\" (non-blocking)\n- `await` = \"I'll wait here\" (blocking/pausing)\n- `.then()` adds to microtask queue, function keeps going\n- `await` pauses function execution until resolved\n- Both eventually get the same value, just different timing!",
    tags: ["javascript","quiz"],
  },

{
    id: 'js-156',
    question: "ü§ù What's its value?\n\n```javascript\nPromise.resolve(5);\n```",
    category: 'javascript',
    subcategory: 'promises',
    difficulty: 'medium',
    options: [
          "5",
          "Promise {<pending>: 5}",
          "Promise {<fulfilled>: 5}",
          "Error"
    ],
    correctAnswer: 2,
    explanation: "`Promise.resolve()` is like a **gift wrapper** - whatever you give it, it wraps in a Promise box and hands it back already wrapped!\n\n**Think of it like instant gift wrapping:**\n- You give them a toy ‚Üí They hand back a wrapped gift with the toy inside\n- You give them a book ‚Üí They hand back a wrapped gift with the book inside\n- You give them an already-wrapped gift ‚Üí They just hand it back (don't double-wrap!)\n\n**The key rule: `Promise.resolve()` ALWAYS returns a Promise**\n\n**What's happening:**\n\n```javascript\nPromise.resolve(5);\n```\n\n**Execution:**\n```\nInput: 5 (a regular number)\n‚Üì\nPromise.resolve() wraps it\n‚Üì\nOutput: Promise {<fulfilled>: 5}\n```\n\n**It's NOT the value `5`, it's a Promise CONTAINING `5`**\n\n**Visual representation:**\n```javascript\nPromise.resolve(5)\n‚Üì\nReturns immediately (synchronously)\n‚Üì\nPromise {\n  [[PromiseState]]: \"fulfilled\"\n  [[PromiseResult]]: 5\n}\n```\n\n**Different values you can pass:**\n\n**1. Primitive values (instantly fulfilled):**\n```javascript\nPromise.resolve(5)              // Promise {<fulfilled>: 5}\nPromise.resolve(\"hello\")        // Promise {<fulfilled>: \"hello\"}\nPromise.resolve(true)           // Promise {<fulfilled>: true}\nPromise.resolve(null)           // Promise {<fulfilled>: null}\nPromise.resolve(undefined)      // Promise {<fulfilled>: undefined}\nPromise.resolve()               // Promise {<fulfilled>: undefined}\n```\n\n**2. Objects and arrays (instantly fulfilled):**\n```javascript\nPromise.resolve({ name: \"John\" })  // Promise {<fulfilled>: { name: \"John\" }}\nPromise.resolve([1, 2, 3])         // Promise {<fulfilled>: [1, 2, 3]}\n```\n\n**3. Another Promise (unwraps it):**\n```javascript\nconst innerPromise = Promise.resolve(\"hello\");\nconst outerPromise = Promise.resolve(innerPromise);\n\n// You might expect: Promise<Promise<\"hello\">>\n// But you get:      Promise<\"hello\">\n\nouterPromise.then(value => {\n  console.log(value);  // \"hello\" (not a Promise!)\n});\n```\n\n**How to actually GET the value:**\n\n**Option 1: Use `.then()`**\n```javascript\nconst promise = Promise.resolve(5);\n\npromise.then(value => {\n  console.log(value);  // 5 (the actual number)\n});\n```\n\n**Option 2: Use `await`**\n```javascript\nconst promise = Promise.resolve(5);\nconst value = await promise;  // Must be in async function\n\nconsole.log(value);  // 5\n```\n\n**Real-world use cases:**\n\n**1. Converting a value to a Promise for consistency:**\n```javascript\nfunction getUserData(useCache) {\n  if (useCache) {\n    // Return cached data as a Promise\n    return Promise.resolve(cachedData);\n  } else {\n    // Return fetched data (already a Promise)\n    return fetch('/api/user').then(res => res.json());\n  }\n}\n\n// Now both paths return Promises!\ngetUserData(true).then(data => console.log(data));\ngetUserData(false).then(data => console.log(data));\n```\n\n**2. Starting a Promise chain:**\n```javascript\nPromise.resolve(5)\n  .then(x => x * 2)      // 10\n  .then(x => x + 3)      // 13\n  .then(x => x / 2)      // 6.5\n  .then(x => console.log(x));  // 6.5\n```\n\n**3. Converting synchronous code to async:**\n```javascript\nfunction validateUser(user) {\n  // Synchronous validation\n  if (!user.email) {\n    return Promise.reject(new Error('Email required'));\n  }\n  \n  // Return success as Promise\n  return Promise.resolve(user);\n}\n\n// Now it can be used in async chains\nvalidateUser({ email: 'test@example.com' })\n  .then(user => saveToDatabase(user))\n  .then(() => console.log('Saved!'))\n  .catch(err => console.error(err));\n```\n\n**4. Handling thenable objects:**\n```javascript\n// A \"thenable\" is an object with a .then() method\nconst thenable = {\n  then: function(resolve, reject) {\n    resolve(42);\n  }\n};\n\nPromise.resolve(thenable).then(value => {\n  console.log(value);  // 42\n});\n// Promise.resolve() recognizes it has .then() and treats it like a Promise!\n```\n\n**Common mistake - thinking it returns the value:**\n```javascript\n// ‚ùå Wrong:\nconst value = Promise.resolve(5);\nif (value === 5) {  // false! value is a Promise\n  console.log('Five!');\n}\n\n// ‚úÖ Correct:\nconst promise = Promise.resolve(5);\npromise.then(value => {\n  if (value === 5) {  // true! value is the number\n    console.log('Five!');\n  }\n});\n\n// ‚úÖ Or with await:\nconst value = await Promise.resolve(5);\nif (value === 5) {  // true!\n  console.log('Five!');\n}\n```\n\n**Difference from Promise constructor:**\n\n**Promise.resolve() - Instant fulfillment:**\n```javascript\nconst promise1 = Promise.resolve(5);\n// Already fulfilled with 5\n```\n\n**Promise constructor - Controlled resolution:**\n```javascript\nconst promise2 = new Promise((resolve, reject) => {\n  setTimeout(() => resolve(5), 1000);  // Resolves after 1 second\n});\n```\n\n**Fun fact - it's synchronous:**\n```javascript\nconsole.log('Before');\nconst promise = Promise.resolve(5);\nconsole.log('After');\nconsole.log(promise);  // Promise {<fulfilled>: 5}\n\n// Output:\n// Before\n// After\n// Promise {<fulfilled>: 5}\n\n// The Promise is created and fulfilled synchronously!\n// But getting the value still requires .then() or await\n```\n\n**Unwrapping nested Promises:**\n```javascript\nconst p1 = Promise.resolve(5);\nconst p2 = Promise.resolve(p1);\nconst p3 = Promise.resolve(p2);\n\np3.then(value => {\n  console.log(value);  // 5 (not a Promise!)\n});\n\n// Promise.resolve() automatically unwraps all the way down!\n```\n\n**Comparison with Promise.reject():**\n```javascript\nPromise.resolve(5)   // Promise {<fulfilled>: 5}\nPromise.reject(5)    // Promise {<rejected>: 5}\n\n// resolve ‚Üí .then() handler\n// reject ‚Üí .catch() handler\n\nPromise.resolve(5).then(x => console.log(x));     // Logs: 5\nPromise.reject(5).catch(x => console.log(x));     // Logs: 5\n```\n\n**Memory tricks:**\n- `Promise.resolve()` = Instant gift wrapper\n- ALWAYS returns a Promise (never the raw value)\n- Already fulfilled when created (no waiting!)\n- Unwraps nested Promises automatically\n- Use `.then()` or `await` to get the value\n- Great for converting sync values to Promises",
    tags: ["javascript","quiz"],
  },

{
    id: 'js-157',
    question: "üìù What's the output?\n\n```javascript\nasync function* range(start, end) {\n  for (let i = start; i <= end; i++) {\n    yield Promise.resolve(i);\n  }\n}\n\n(async () => {\n  const gen = range(1, 3);\n  for await (const item of gen) {\n    console.log(item);\n  }\n})();\n```",
    category: 'javascript',
    subcategory: 'promises',
    difficulty: 'medium',
    options: [
          "Promise {1} Promise {2} Promise {3}",
          "Promise {<pending>} Promise {<pending>} Promise {<pending>}",
          "1 2 3",
          "undefined undefined undefined"
    ],
    correctAnswer: 2,
    explanation: "`for await...of` with async generators is like a **smart unpacking machine** - it automatically waits for and unwraps each Promise before giving you the value!\n\n**Think of it like an assembly line:**\n- Generator: Produces wrapped boxes (Promises) one at a time\n- `for await...of`: Waits for each box, opens it, gives you contents\n- You receive: The actual items, not the boxes!\n\n**The key rule: `for await...of` automatically awaits each Promise**\n\n**What's happening:**\n\n```javascript\nasync function* range(start, end) {\n  for (let i = start; i <= end; i++) {\n    yield Promise.resolve(i);  // Yields: Promise {<fulfilled>: 1}, Promise {<fulfilled>: 2}, etc.\n  }\n}\n```\n\n**Step-by-step execution:**\n\n**Step 1: Create the async generator**\n```javascript\nconst gen = range(1, 3);\n‚Üì\ngen is now an async generator object\nNothing has executed yet (generators are lazy!)\n```\n\n**Step 2: Start the `for await...of` loop**\n```javascript\nfor await (const item of gen) {\n  console.log(item);\n}\n```\n\n**Iteration 1:**\n```\n1. Loop calls gen.next()\n2. Generator yields Promise.resolve(1)\n3. for await...of sees a Promise\n4. Automatically awaits it ‚Üí gets 1\n5. Sets item = 1\n6. console.log(item) ‚Üí logs: 1\n```\n\n**Iteration 2:**\n```\n1. Loop calls gen.next() again\n2. Generator yields Promise.resolve(2)\n3. for await...of awaits it ‚Üí gets 2\n4. Sets item = 2\n5. console.log(item) ‚Üí logs: 2\n```\n\n**Iteration 3:**\n```\n1. Loop calls gen.next() again\n2. Generator yields Promise.resolve(3)\n3. for await...of awaits it ‚Üí gets 3\n4. Sets item = 3\n5. console.log(item) ‚Üí logs: 3\n```\n\n**Iteration 4:**\n```\n1. Loop calls gen.next()\n2. Generator is done (i > end)\n3. Loop exits\n```\n\n**Final output:**\n```\n1\n2\n3\n```\n\n**Visual representation:**\n```javascript\n// What the generator yields:\nyield Promise.resolve(1) ‚Üí Promise {<fulfilled>: 1}\nyield Promise.resolve(2) ‚Üí Promise {<fulfilled>: 2}\nyield Promise.resolve(3) ‚Üí Promise {<fulfilled>: 3}\n\n// What for await...of gives you:\nitem = 1  (unwrapped!)\nitem = 2  (unwrapped!)\nitem = 3  (unwrapped!)\n```\n\n**Comparison with regular `for...of`:**\n\n**Regular `for...of` (no await):**\n```javascript\nfunction* range(start, end) {\n  for (let i = start; i <= end; i++) {\n    yield Promise.resolve(i);\n  }\n}\n\nfor (const item of range(1, 3)) {\n  console.log(item);\n}\n\n// Output:\n// Promise {<fulfilled>: 1}\n// Promise {<fulfilled>: 2}\n// Promise {<fulfilled>: 3}\n// You get the Promises, not the values!\n```\n\n**`for await...of` (with await):**\n```javascript\nasync function* range(start, end) {\n  for (let i = start; i <= end; i++) {\n    yield Promise.resolve(i);\n  }\n}\n\nfor await (const item of range(1, 3)) {\n  console.log(item);\n}\n\n// Output:\n// 1\n// 2\n// 3\n// You get the unwrapped values!\n```\n\n**What if you yield non-Promises?**\n\n```javascript\nasync function* simpleRange(start, end) {\n  for (let i = start; i <= end; i++) {\n    yield i;  // No Promise.resolve!\n  }\n}\n\nfor await (const item of simpleRange(1, 3)) {\n  console.log(item);\n}\n\n// Output:\n// 1\n// 2\n// 3\n// Works the same! for await...of handles both\n```\n\n**Real-world use cases:**\n\n**1. Streaming data from API (paginated results):**\n```javascript\nasync function* fetchAllUsers() {\n  let page = 1;\n  let hasMore = true;\n  \n  while (hasMore) {\n    const response = await fetch(`/api/users?page=${page}`);\n    const data = await response.json();\n    \n    yield data.users;  // Yield each page\n    \n    hasMore = data.hasMore;\n    page++;\n  }\n}\n\n// Use it:\nfor await (const users of fetchAllUsers()) {\n  console.log('Got page:', users);\n  processUsers(users);\n}\n```\n\n**2. Processing large files in chunks:**\n```javascript\nasync function* readFileInChunks(filename) {\n  const file = await fs.open(filename);\n  \n  while (true) {\n    const chunk = await file.read(1024);  // Read 1KB at a time\n    if (chunk.length === 0) break;\n    \n    yield chunk;\n  }\n  \n  await file.close();\n}\n\nfor await (const chunk of readFileInChunks('large-file.txt')) {\n  processChunk(chunk);\n}\n```\n\n**3. Polling for updates:**\n```javascript\nasync function* pollForUpdates(interval = 1000) {\n  while (true) {\n    const data = await fetch('/api/status').then(r => r.json());\n    yield data;\n    await new Promise(resolve => setTimeout(resolve, interval));\n  }\n}\n\n// Use it:\nfor await (const status of pollForUpdates(5000)) {\n  console.log('Status update:', status);\n  if (status.completed) break;\n}\n```\n\n**How it differs from regular async/await:**\n\n**Multiple awaits in sequence (traditional):**\n```javascript\nasync function processItems() {\n  const item1 = await getItem(1);\n  console.log(item1);\n  \n  const item2 = await getItem(2);\n  console.log(item2);\n  \n  const item3 = await getItem(3);\n  console.log(item3);\n}\n// Repetitive and doesn't scale!\n```\n\n**Async generator (better):**\n```javascript\nasync function* getItems() {\n  for (let i = 1; i <= 3; i++) {\n    yield await getItem(i);\n  }\n}\n\nfor await (const item of getItems()) {\n  console.log(item);\n}\n// Clean and scalable!\n```\n\n**Common gotcha - forgetting `async` or `await`:**\n\n```javascript\n// ‚ùå Wrong: Missing async keyword\nfunction* range(start, end) {  // Not async!\n  for (let i = start; i <= end; i++) {\n    yield Promise.resolve(i);\n  }\n}\n\nfor await (const item of range(1, 3)) {  // Error! Not an async iterable\n  console.log(item);\n}\n\n// ‚ùå Wrong: Using regular for...of\nasync function* range(start, end) {\n  for (let i = start; i <= end; i++) {\n    yield Promise.resolve(i);\n  }\n}\n\nfor (const item of range(1, 3)) {  // Missing await!\n  console.log(item);  // Logs Promises, not values\n}\n\n// ‚úÖ Correct:\nasync function* range(start, end) {  // async function*\n  for (let i = start; i <= end; i++) {\n    yield Promise.resolve(i);\n  }\n}\n\nfor await (const item of range(1, 3)) {  // for await...of\n  console.log(item);  // Logs: 1, 2, 3\n}\n```\n\n**Breaking out early:**\n```javascript\nasync function* infiniteRange() {\n  let i = 0;\n  while (true) {\n    yield Promise.resolve(i++);\n  }\n}\n\nfor await (const num of infiniteRange()) {\n  console.log(num);\n  if (num >= 5) break;  // Stop at 5\n}\n// Output: 0, 1, 2, 3, 4, 5\n```\n\n**Error handling:**\n```javascript\nasync function* riskyGenerator() {\n  yield Promise.resolve(1);\n  yield Promise.reject(new Error('Oops!'));\n  yield Promise.resolve(3);  // Never reached\n}\n\ntry {\n  for await (const item of riskyGenerator()) {\n    console.log(item);\n  }\n} catch (err) {\n  console.error('Caught:', err.message);  // \"Caught: Oops!\"\n}\n\n// Output:\n// 1\n// Caught: Oops!\n```\n\n**Manual control (like .next()):**\n```javascript\nconst gen = range(1, 3);\n\nconst result1 = await gen.next();  // { value: 1, done: false }\nconsole.log(result1.value);        // 1\n\nconst result2 = await gen.next();  // { value: 2, done: false }\nconsole.log(result2.value);        // 2\n\nconst result3 = await gen.next();  // { value: 3, done: false }\nconsole.log(result3.value);        // 3\n\nconst result4 = await gen.next();  // { value: undefined, done: true }\nconsole.log(result4.done);         // true\n```\n\n**Memory tricks:**\n- `async function*` = Async generator (yields Promises)\n- `for await...of` = Auto-unwraps Promises from async iterables\n- Each iteration automatically awaits the yielded value\n- Great for streaming, pagination, and sequential async operations\n- Can break/continue/return just like regular loops\n- Lazy - only processes when you iterate",
    tags: ["javascript","quiz"],
  },

{
    id: 'js-158',
    question: "üñ•Ô∏è What's the output?\n\n```javascript\nconst myPromise = Promise.resolve(\"Woah some cool data\");\n\n(async () => {\n  try {\n    console.log(await myPromise);\n  } catch {\n    throw new Error(`Oops didn't work`);\n  } finally {\n    console.log(\"Oh finally!\");\n  }\n})();\n```",
    category: 'javascript',
    subcategory: 'promises',
    difficulty: 'medium',
    options: [
          "Woah some cool data",
          "Oh finally!",
          "Woah some cool data Oh finally!",
          "Oops didn't work Oh finally!"
    ],
    correctAnswer: 2,
    explanation: "`try/catch/finally` with Promises is like a **safety net system** - try the risky stuff, catch if it fails, but **finally ALWAYS runs** no matter what!\n\n**Think of it like a trapeze act:**\n- `try`: Attempt the dangerous trick\n- `catch`: Safety net catches you if you fall\n- `finally`: Bow to the audience (happens whether you succeed or fall!)\n\n**The key rule: `finally` ALWAYS executes, success or failure**\n\n**What's happening:**\n\n```javascript\nconst myPromise = Promise.resolve(\"Woah some cool data\");\n\n(async () => {\n  try {\n    console.log(await myPromise);         // Try this\n  } catch {\n    throw new Error(`Oops didn't work`);  // Only if error\n  } finally {\n    console.log(\"Oh finally!\");           // ALWAYS runs\n  }\n})();\n```\n\n**Step-by-step execution:**\n\n**Step 1: Try block**\n```\n1. Await myPromise\n   ‚Üí It resolves with \"Woah some cool data\"\n   \n2. console.log(await myPromise)\n   ‚Üí Logs: \"Woah some cool data\"\n   \n3. No error thrown!\n   ‚Üí Skip catch block\n```\n\n**Step 2: Catch block**\n```\nNo errors occurred in try block\n‚Üí catch block is SKIPPED\n‚Üí throw new Error() never executes\n```\n\n**Step 3: Finally block**\n```\nfinally ALWAYS runs\n‚Üí console.log(\"Oh finally!\")\n‚Üí Logs: \"Oh finally!\"\n```\n\n**Final output:**\n```\nWoah some cool data\nOh finally!\n```\n\n**Visual execution flow:**\n```javascript\ntry {\n  console.log(await myPromise);  ‚úì Executes ‚Üí \"Woah some cool data\"\n} catch {                         ‚úó Skipped (no error)\n  throw new Error(...);\n} finally {                       ‚úì ALWAYS executes ‚Üí \"Oh finally!\"\n  console.log(\"Oh finally!\");\n}\n```\n\n**What if there WAS an error?**\n\n```javascript\nconst myPromise = Promise.reject(\"Error!\");\n\n(async () => {\n  try {\n    console.log(await myPromise);         // Throws error!\n  } catch (err) {\n    console.log(`Caught: ${err}`);        // Runs!\n  } finally {\n    console.log(\"Oh finally!\");           // Still runs!\n  }\n})();\n\n// Output:\n// Caught: Error!\n// Oh finally!\n```\n\n**All possible paths:**\n\n**Path 1: Success (no error)**\n```javascript\ntry {\n  console.log(await Promise.resolve(\"success\"));  // ‚úì Runs\n} catch {\n  console.log(\"error\");                           // ‚úó Skipped\n} finally {\n  console.log(\"cleanup\");                         // ‚úì Runs\n}\n// Output:\n// success\n// cleanup\n```\n\n**Path 2: Error caught**\n```javascript\ntry {\n  console.log(await Promise.reject(\"fail\"));  // ‚úó Throws\n} catch (err) {\n  console.log(`error: ${err}`);               // ‚úì Runs\n} finally {\n  console.log(\"cleanup\");                     // ‚úì Runs\n}\n// Output:\n// error: fail\n// cleanup\n```\n\n**Path 3: Error thrown in catch (uncaught)**\n```javascript\ntry {\n  console.log(await Promise.reject(\"fail\"));  // ‚úó Throws\n} catch (err) {\n  console.log(`caught: ${err}`);              // ‚úì Runs\n  throw new Error(\"Re-thrown!\");              // Throws again!\n} finally {\n  console.log(\"cleanup\");                     // ‚úì Still runs!\n}\n// Output:\n// caught: fail\n// cleanup\n// Uncaught Error: Re-thrown!\n```\n\n**Real-world use case - cleanup resources:**\n\n```javascript\nlet connection = null;\n\ntry {\n  connection = await database.connect();\n  const data = await connection.query('SELECT * FROM users');\n  console.log('Got data:', data);\n} catch (err) {\n  console.error('Database error:', err);\n} finally {\n  // ALWAYS close the connection!\n  if (connection) {\n    await connection.close();\n    console.log('Connection closed');\n  }\n}\n// finally ensures we don't leak database connections\n```\n\n**Another example - loading states:**\n\n```javascript\nlet isLoading = true;\n\ntry {\n  const data = await fetchData();\n  displayData(data);\n} catch (err) {\n  showError(err);\n} finally {\n  // ALWAYS hide loading spinner\n  isLoading = false;\n  hideLoadingSpinner();\n}\n```\n\n**Finally with return statements:**\n\n```javascript\nasync function test() {\n  try {\n    return \"from try\";\n  } finally {\n    console.log(\"finally runs!\");\n  }\n}\n\nawait test();\n// Output:\n// finally runs!\n// Returns: \"from try\"\n// finally runs BEFORE the return!\n```\n\n**Finally can override return value:**\n\n```javascript\nasync function test() {\n  try {\n    return \"from try\";\n  } finally {\n    return \"from finally\";  // This wins!\n  }\n}\n\nawait test();  // Returns: \"from finally\"\n// finally's return overrides try's return\n```\n\n**Common mistake - thinking catch prevents finally:**\n\n```javascript\n// ‚ùå Wrong assumption:\n\"If catch handles the error, finally won't run\"\n\n// ‚úÖ Reality:\ntry {\n  throw new Error('Oops');\n} catch (err) {\n  console.log('Handled');  // Runs\n} finally {\n  console.log('Cleanup');  // STILL runs!\n}\n\n// Output:\n// Handled\n// Cleanup\n```\n\n**Multiple async operations:**\n\n```javascript\ntry {\n  const user = await fetchUser();\n  const posts = await fetchPosts(user.id);\n  const comments = await fetchComments(posts[0].id);\n  console.log('All done!');\n} catch (err) {\n  // Catches errors from ANY of the awaits\n  console.error('Something failed:', err);\n} finally {\n  // Runs after everything, regardless of which await failed\n  console.log('Finished attempt');\n}\n```\n\n**Without async/await (using .then/.catch):**\n\n```javascript\nmyPromise\n  .then(data => {\n    console.log(data);  // \"Woah some cool data\"\n  })\n  .catch(err => {\n    console.error(err);\n  })\n  .finally(() => {\n    console.log(\"Oh finally!\");  // ALWAYS runs\n  });\n\n// Same behavior!\n```\n\n**Nested try/finally:**\n\n```javascript\ntry {\n  console.log('Outer try');\n  try {\n    console.log('Inner try');\n    throw new Error('Inner error');\n  } finally {\n    console.log('Inner finally');  // Runs!\n  }\n} catch (err) {\n  console.log('Caught:', err.message);  // Catches inner error\n} finally {\n  console.log('Outer finally');  // Runs!\n}\n\n// Output:\n// Outer try\n// Inner try\n// Inner finally\n// Caught: Inner error\n// Outer finally\n```\n\n**Memory tricks:**\n- `finally` = \"No matter what happens, do this\"\n- Perfect for cleanup: close connections, hide spinners, release locks\n- Runs whether try succeeds, catch runs, or errors are thrown\n- Can override return values (be careful!)\n- Works with both async/await and .then()/.catch()\n- Think: \"Finally, after all that...\"",
    tags: ["javascript","quiz"],
  },

{
    id: 'js-159',
    question: "üñ•Ô∏è What's the output?\n\n```javascript\nconst myPromise = Promise.resolve(Promise.resolve(\"Promise\"));\n\nfunction funcOne() {\n  setTimeout(() => console.log(\"Timeout 1!\"), 0);\n  myPromise.then((res) => res).then((res) => console.log(`${res} 1!`));\n  console.log(\"Last line 1!\");\n}\n\nasync function funcTwo() {\n  const res = await myPromise;\n  console.log(`${res} 2!`);\n  setTimeout(() => console.log(\"Timeout 2!\"), 0);\n  console.log(\"Last line 2!\");\n}\n\nfuncOne();\nfuncTwo();\n```",
    category: 'javascript',
    subcategory: 'promises',
    difficulty: 'medium',
    options: [
          "Promise 1! Last line 1! Promise 2! Last line 2! Timeout 1! Timeout 2!",
          "Last line 1! Timeout 1! Promise 1! Last line 2! Promise2! Timeout 2!",
          "Last line 1! Promise 2! Last line 2! Promise 1! Timeout 1! Timeout 2!",
          "Timeout 1! Promise 1! Last line 1! Promise 2! Timeout 2! Last line 2!"
    ],
    correctAnswer: 2,
    explanation: "First, we invoke `funcOne`. On the first line of `funcOne`, we call the _asynchronous_ `setTimeout` function, from which the callback is sent to the Web API. (see my article on the event loop here.)\n\nThen we call the `myPromise` promise, which is an _asynchronous_ operation. Pay attention, that now only the first then clause was added to the microtask queue.\n\nBoth the promise and the timeout are asynchronous operations, the function keeps on running while it's busy completing the promise and handling the `setTimeout` callback. This means that `Last line 1!` gets logged first, since this is not an asynchonous operation.\n\nSince the callstack is not empty yet, the `setTimeout` function and promise in `funcOne` cannot get added to the callstack yet.\n\nIn `funcTwo`, the variable `res` gets `Promise` because `Promise.resolve(Promise.resolve('Promise'))` is equivalent to `Promise.resolve('Promise')` since resolving a promise just resolves it's value. The `await` in this line stops the execution of the function until it receives the resolution of the promise and then keeps on running synchronously until completion, so `Promise 2!` and then `Last line 2!` are logged and the `setTimeout` is sent to the Web API. If the first then clause in `funcOne` had its own log statement, it would be printed before `Promise 2!`. Howewer, it executed silently and put the second then clause in microtask queue. So, the second clause will be printed after `Promise 2!`.\n\nThen the call stack is empty. Promises are _microtasks_ so they are resolved first when the call stack is empty so `Promise 1!` gets to be logged.\n\nNow, since `funcTwo` popped off the call stack, the call stack is empty. The callbacks waiting in the queue (`() => console.log(\"Timeout 1!\")` from `funcOne`, and `() => console.log(\"Timeout 2!\")` from `funcTwo`) get added to the call stack one by one. The first callback logs `Timeout 1!`, and gets popped off the stack. Then, the second callback logs `Timeout 2!`, and gets popped off the stack.",
    tags: ["javascript","quiz"],
  },

{
    id: 'js-160',
    question: "üñ•Ô∏è What's the output?\n\n```javascript\nconst promise1 = Promise.resolve(\"First\");\nconst promise2 = Promise.resolve(\"Second\");\nconst promise3 = Promise.reject(\"Third\");\nconst promise4 = Promise.resolve(\"Fourth\");\n\nconst runPromises = async () => {\n  const res1 = await Promise.all([promise1, promise2]);\n  const res2 = await Promise.all([promise3, promise4]);\n  return [res1, res2];\n};\n\nrunPromises()\n  .then((res) => console.log(res))\n  .catch((err) => console.log(err));\n```",
    category: 'javascript',
    subcategory: 'promises',
    difficulty: 'medium',
    options: [
          "[['First', 'Second'], ['Fourth']]",
          "[['First', 'Second'], ['Third', 'Fourth']]",
          "[['First', 'Second']]",
          "'Third'"
    ],
    correctAnswer: 3,
    explanation: "`Promise.all()` is like an **all-or-nothing team race** - if even ONE team member fails, the entire team is disqualified immediately!\n\n**Think of it like a relay race:**\n- All runners must finish successfully for the team to win\n- If ANY runner drops the baton ‚Üí entire team loses\n- The team's result is the baton drop (not the successful runners)\n- Remaining runners still finish their legs, but the team already lost\n\n**The key rule: `Promise.all()` rejects immediately when ANY promise rejects**\n\n**What's happening:**\n\n```javascript\nconst promise1 = Promise.resolve(\"First\");\nconst promise2 = Promise.resolve(\"Second\");\nconst promise3 = Promise.reject(\"Third\");   // This one fails!\nconst promise4 = Promise.resolve(\"Fourth\");\n\nconst runPromises = async () => {\n  const res1 = await Promise.all([promise1, promise2]);  // ‚úì Works\n  const res2 = await Promise.all([promise3, promise4]);  // ‚úó Rejects!\n  return [res1, res2];\n};\n\nrunPromises()\n  .then((res) => console.log(res))\n  .catch((err) => console.log(err));  // Catches \"Third\"\n```\n\n**Step-by-step execution:**\n\n**Step 1: First `Promise.all()`**\n```javascript\nconst res1 = await Promise.all([promise1, promise2]);\n‚Üì\nBoth promises resolve successfully:\n  promise1 ‚Üí \"First\"\n  promise2 ‚Üí \"Second\"\n‚Üì\nres1 = [\"First\", \"Second\"]\n‚úì Success! Continue...\n```\n\n**Step 2: Second `Promise.all()`**\n```javascript\nconst res2 = await Promise.all([promise3, promise4]);\n‚Üì\npromise3 rejects with \"Third\"\npromise4 resolves with \"Fourth\" (but doesn't matter!)\n‚Üì\nPromise.all() rejects immediately with \"Third\"\n‚Üì\nThrows error, skips rest of function\n‚Üì\nGoes to .catch() handler\n```\n\n**Step 3: Catch block**\n```javascript\n.catch((err) => console.log(err));\n‚Üì\nerr = \"Third\" (the rejection value from promise3)\n‚Üì\nLogs: \"Third\"\n```\n\n**Final output:**\n```\nThird\n```\n\n**Visual execution flow:**\n```javascript\nrunPromises()\n  ‚Üì\nres1 = await Promise.all([promise1, promise2])\n  ‚úì Both resolve ‚Üí res1 = [\"First\", \"Second\"]\n  ‚Üì\nres2 = await Promise.all([promise3, promise4])\n  ‚úó promise3 rejects with \"Third\"\n  ‚úó Function stops here, throws \"Third\"\n  ‚úó Never reaches: return [res1, res2]\n  ‚Üì\n.catch((err) => console.log(err))\n  ‚Üì err = \"Third\"\n  Logs: \"Third\"\n```\n\n**How `Promise.all()` behaves:**\n\n**All succeed:**\n```javascript\nPromise.all([\n  Promise.resolve(1),\n  Promise.resolve(2),\n  Promise.resolve(3)\n]).then(results => {\n  console.log(results);  // [1, 2, 3]\n});\n```\n\n**One fails:**\n```javascript\nPromise.all([\n  Promise.resolve(1),\n  Promise.reject('Error!'),  // This one fails\n  Promise.resolve(3)\n]).catch(err => {\n  console.log(err);  // \"Error!\"\n  // We don't get [1, ?, 3] - we get the error only\n});\n```\n\n**Multiple fail (first one wins):**\n```javascript\nPromise.all([\n  Promise.reject('First error'),   // Rejects at 100ms\n  Promise.reject('Second error'),  // Rejects at 200ms\n]).catch(err => {\n  console.log(err);  // \"First error\"\n  // Promise.all rejects with the FIRST rejection\n});\n```\n\n**Real-world example - fetching user data:**\n\n```javascript\nasync function getUserProfile(userId) {\n  try {\n    const [user, posts, friends] = await Promise.all([\n      fetchUser(userId),      // If this fails...\n      fetchPosts(userId),\n      fetchFriends(userId)\n    ]);\n    \n    return { user, posts, friends };\n  } catch (err) {\n    // ...we catch it here and get nothing\n    console.error('Failed to load profile:', err);\n    return null;\n  }\n}\n```\n\n**Comparison with other Promise methods:**\n\n**`Promise.all()` - All must succeed, fail-fast:**\n```javascript\nPromise.all([\n  Promise.resolve(1),\n  Promise.reject('error'),\n  Promise.resolve(3)\n]).catch(err => console.log(err));  // \"error\" (stops immediately)\n```\n\n**`Promise.allSettled()` - Wait for all, no matter what:**\n```javascript\nPromise.allSettled([\n  Promise.resolve(1),\n  Promise.reject('error'),\n  Promise.resolve(3)\n]).then(results => {\n  console.log(results);\n  // [\n  //   { status: 'fulfilled', value: 1 },\n  //   { status: 'rejected', reason: 'error' },\n  //   { status: 'fulfilled', value: 3 }\n  // ]\n});\n```\n\n**`Promise.race()` - First to finish (resolve or reject):**\n```javascript\nPromise.race([\n  Promise.resolve(1),\n  Promise.reject('error'),\n  Promise.resolve(3)\n]).then(\n  result => console.log('Won:', result),\n  err => console.log('Lost:', err)\n);\n// Logs whichever finishes first\n```\n\n**`Promise.any()` - First to succeed (ignores rejections):**\n```javascript\nPromise.any([\n  Promise.reject('error1'),\n  Promise.resolve(2),      // This one wins!\n  Promise.reject('error3')\n]).then(result => console.log(result));  // 2\n```\n\n**When to use `Promise.all()`:**\n\n**‚úÖ Good use cases:**\n```javascript\n// 1. Independent operations that all must succeed\nconst [userData, settingsData, preferencesData] = await Promise.all([\n  fetchUser(),\n  fetchSettings(),\n  fetchPreferences()\n]);\n// If any fail, we can't proceed anyway\n\n// 2. Parallel validation\nconst validations = await Promise.all([\n  validateEmail(email),\n  validatePassword(password),\n  validateUsername(username)\n]);\n// All must pass for registration to succeed\n\n// 3. Bulk operations\nconst results = await Promise.all(\n  userIds.map(id => deleteUser(id))\n);\n// All deletions must succeed\n```\n\n**‚ùå When NOT to use `Promise.all()`:**\n```javascript\n// 1. When some failures are acceptable\n// Use Promise.allSettled() instead:\nconst results = await Promise.allSettled([\n  fetchRecommendedProducts(),  // Nice to have\n  fetchRelatedItems(),         // Nice to have\n  fetchReviews()               // Nice to have\n]);\n// Can show whatever succeeded\n\n// 2. When operations depend on each other\n// Use sequential awaits instead:\nconst user = await fetchUser();\nconst posts = await fetchPosts(user.id);  // Needs user.id!\nconst comments = await fetchComments(posts[0].id);  // Needs posts!\n\n// 3. When you want the first success\n// Use Promise.race() or Promise.any() instead:\nconst fastestResult = await Promise.race([\n  fetchFromCDN1(),\n  fetchFromCDN2(),\n  fetchFromCDN3()\n]);\n```\n\n**Common gotcha - rejected promises still execute:**\n\n```javascript\nconst promise1 = new Promise((resolve) => {\n  setTimeout(() => {\n    console.log('Promise 1 finished');\n    resolve('First');\n  }, 2000);\n});\n\nconst promise2 = Promise.reject('Error!');\n\nPromise.all([promise1, promise2]).catch(err => {\n  console.log('Caught:', err);  // Logs immediately: \"Caught: Error!\"\n});\n\n// After 2 seconds:\n// \"Promise 1 finished\"\n// promise1 still completes! It's not cancelled\n```\n\n**Error handling strategies:**\n\n**Strategy 1: Fail-fast (default):**\n```javascript\ntry {\n  const results = await Promise.all(promises);\n  // All succeeded\n} catch (err) {\n  // Any failed - stop everything\n  console.error('Operation failed:', err);\n}\n```\n\n**Strategy 2: Partial success acceptable:**\n```javascript\nconst results = await Promise.allSettled(promises);\nconst succeeded = results.filter(r => r.status === 'fulfilled');\nconst failed = results.filter(r => r.status === 'rejected');\n\nconsole.log(`${succeeded.length} succeeded, ${failed.length} failed`);\n```\n\n**Strategy 3: Wrap individual promises to prevent failures:**\n```javascript\nconst safePromises = promises.map(p => \n  p.catch(err => ({ error: err }))  // Convert rejections to resolutions\n);\n\nconst results = await Promise.all(safePromises);\n// Now Promise.all never rejects!\nconst errors = results.filter(r => r.error);\n```\n\n**Timing example:**\n```javascript\nconst slow = new Promise(resolve => setTimeout(() => resolve('slow'), 3000));\nconst fast = new Promise((_, reject) => setTimeout(() => reject('fast'), 100));\n\nPromise.all([slow, fast])\n  .then(results => console.log('Success:', results))\n  .catch(err => console.log('Failed:', err));\n\n// After 100ms:\n// \"Failed: fast\"\n// Promise.all rejects immediately when fast rejects\n// (slow is still running but result is ignored)\n```\n\n**Memory tricks:**\n- `Promise.all()` = \"All or nothing\" - one failure ruins everything\n- Rejects immediately (fail-fast) with first rejection\n- Returns array of results in same order as input\n- Perfect when all operations must succeed\n- Use `Promise.allSettled()` when partial success is OK\n- Rejected promises still complete, they're not cancelled",
    tags: ["javascript","quiz"],
  },

{
    id: 'js-166',
    question: "üñ•Ô∏è What's the output?\n\n```javascript\nconst person = {\n  name: \"Lydia\",\n  age: 21,\n};\n\nfor (const item in person) {\n  console.log(item);\n}\n```",
    category: 'javascript',
    subcategory: 'promises',
    difficulty: 'medium',
    options: [
          "{ name: \"Lydia\" }, { age: 21 }",
          "\"name\", \"age\"",
          "\"Lydia\", 21",
          "[\"name\", \"Lydia\"], [\"age\", 21]"
    ],
    correctAnswer: 1,
    explanation: "With a `for-in` loop, we can iterate through object keys, in this case `name` and `age`. Under the hood, object keys are strings (if they're not a Symbol). On every loop, we set the value of `item` equal to the current key it‚Äôs iterating over. First, `item` is equal to `name`, and gets logged. Then, `item` is equal to `age`, which gets logged.",
    tags: ["javascript","quiz"],
  }
];
