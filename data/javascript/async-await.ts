import { QuizQuestion } from '../../types/quiz';

export const async_awaitQuizzes: QuizQuestion[] = [
{
    id: 'js-209',
    question: "üìù What's the output?\n\n```javascript\nasync function test() {\n  return 'Hello';\n}\n\nconsole.log(test());\n```",
    category: 'javascript',
    subcategory: 'async-await',
    difficulty: 'easy',
    options: [
      'Hello',
      'Promise {<fulfilled>: "Hello"}',
      'undefined',
      'Promise {<pending>}',
    ],
    correctAnswer: 1,
    explanation: "Async functions always return a Promise, even if you return a non-Promise value. The value 'Hello' is automatically wrapped in a resolved Promise. To get the actual value, you need to use .then() or await.",
    tags: ['async', 'await', 'promises'],
  },

{
    id: 'js-210',
    question: "üìù What's the output?\n\n```javascript\nasync function getData() {\n  return await Promise.resolve('Data');\n}\n\ngetData().then(result => console.log(result));\n```",
    category: 'javascript',
    subcategory: 'async-await',
    difficulty: 'easy',
    options: [
      'Promise {<fulfilled>: "Data"}',
      'Data',
      'undefined',
      'Error',
    ],
    correctAnswer: 1,
    explanation: "The await keyword waits for the Promise to resolve and returns the resolved value ('Data'). The async function then wraps this in a new Promise, which is handled by .then(), logging 'Data'.",
    tags: ['async', 'await', 'promises'],
  },

{
    id: 'js-211',
    question: "üìù What's the output?\n\n```javascript\nasync function test() {\n  console.log('1');\n  await Promise.resolve();\n  console.log('2');\n}\n\ntest();\nconsole.log('3');\n```",
    category: 'javascript',
    subcategory: 'async-await',
    difficulty: 'medium',
    options: [
      '1 2 3',
      '1 3 2',
      '3 1 2',
      '1 2 3 or 1 3 2 (unpredictable)',
    ],
    correctAnswer: 1,
    explanation: "**await pauses the function, not the program!** Like hitting pause on one video while others keep playing.\n\n**What happens:**\n```javascript\nasync function test() {\n  console.log('1');          // ‚Üê Runs immediately\n  await Promise.resolve();   // ‚Üê Pauses HERE\n  console.log('2');          // ‚Üê Waits for microtask\n}\n\ntest();\nconsole.log('3');  // ‚Üê Runs while test() is paused\n```\n\n**Timeline:**\n```\n0ms: test() called\n0ms:   console.log('1') ‚Üí logs '1'\n0ms:   await Promise.resolve() ‚Üí function PAUSES\n0ms: test() returns Promise (pending)\n0ms: console.log('3') ‚Üí logs '3'\n0ms: Call stack empty\n1ms: Microtask runs ‚Üí resume test()\n1ms:   console.log('2') ‚Üí logs '2'\n\nOutput: 1 3 2\n```\n\n**Visual flow:**\n```javascript\ntest()                     // Call function\n  ‚Üì\nconsole.log('1')          // Logs: 1\n  ‚Üì\nawait Promise.resolve()   // PAUSE! Schedule microtask\n  ‚Üì                        // Function yields control\nconsole.log('3')          // Logs: 3 (outside continues!)\n  ‚Üì\n// Microtask queue\nconsole.log('2')          // Logs: 2 (resume)\n```\n\n**Memory trick:** await = \"I'll wait here, you go ahead!\"",
    tags: ['async', 'await', 'event-loop'],
  },

{
    id: 'js-212',
    question: "üìù What's the output?\n\n```javascript\nasync function test() {\n  try {\n    await Promise.reject('Error!');\n  } catch (err) {\n    return 'Caught';\n  }\n}\n\ntest().then(result => console.log(result));\n```",
    category: 'javascript',
    subcategory: 'async-await',
    difficulty: 'medium',
    options: [
      'Error!',
      'Caught',
      'undefined',
      'Uncaught Error',
    ],
    correctAnswer: 1,
    explanation: "When a Promise is rejected in an async function, it throws an error that can be caught with try/catch. The catch block returns 'Caught', which becomes the resolved value of the Promise returned by test().",
    tags: ['async', 'await', 'error-handling'],
  },

{
    id: 'js-213',
    question: "üìù What's the output?\n\n```javascript\nasync function test() {\n  const p1 = Promise.resolve('First');\n  const p2 = Promise.resolve('Second');\n  \n  const r1 = await p1;\n  const r2 = await p2;\n  \n  console.log(r1, r2);\n}\n\ntest();\n```",
    category: 'javascript',
    subcategory: 'async-await',
    difficulty: 'easy',
    options: [
      'First Second',
      'Promise Promise',
      'undefined undefined',
      'Error',
    ],
    correctAnswer: 0,
    explanation: "Each await waits for the Promise to resolve and returns the value. Since both Promises are already resolved, r1 gets 'First' and r2 gets 'Second', both log immediately.",
    tags: ['async', 'await', 'promises'],
  },

{
    id: 'js-214',
    question: "üìù Which runs faster?\n\n```javascript\n// Option A\nasync function optionA() {\n  const a = await fetch('/api/a');\n  const b = await fetch('/api/b');\n  return [a, b];\n}\n\n// Option B\nasync function optionB() {\n  const [a, b] = await Promise.all([\n    fetch('/api/a'),\n    fetch('/api/b')\n  ]);\n  return [a, b];\n}\n```",
    category: 'javascript',
    subcategory: 'async-await',
    difficulty: 'medium',
    options: [
      'Option A is faster',
      'Option B is faster',
      'Same speed',
      'Depends on network',
    ],
    correctAnswer: 1,
    explanation: "**Sequential vs Parallel execution** - huge performance difference!\n\n**Option A (Sequential - SLOW):**\n```javascript\nconst a = await fetch('/api/a');  // Wait 1s\nconst b = await fetch('/api/b');  // Wait another 1s\n// Total: 2 seconds\n```\n\n**Option B (Parallel - FAST):**\n```javascript\nconst [a, b] = await Promise.all([\n  fetch('/api/a'),  // Both start at same time\n  fetch('/api/b')\n]);\n// Total: 1 second (overlapped)\n```\n\n**Timeline comparison:**\n```\nOption A (Sequential):\n0s ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ fetch /api/a ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫  fetch /api/b ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ Done\n         [1 second]            [1 second]          = 2s\n\nOption B (Parallel):\n0s ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ fetch /api/a ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ Done\n     ‚îú‚îÄ‚îÄ‚ñ∫ fetch /api/b ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ ‚îò\n         [Both 1 second]      = 1s\n```\n\n**Rule:** await waits ‚Üí use Promise.all() for parallel!\n\n**Real-world example:**\n```javascript\n// ‚ùå Slow: 3 seconds\nconst user = await fetchUser();\nconst posts = await fetchPosts();\nconst comments = await fetchComments();\n\n// ‚úÖ Fast: 1 second (all at once)\nconst [user, posts, comments] = await Promise.all([\n  fetchUser(),\n  fetchPosts(),\n  fetchComments()\n]);\n```\n\n**Memory trick:** Sequential await = waterfall (one after another). Promise.all() = parallel (all at once).",
    tags: ['async', 'await', 'promises', 'performance'],
  },

{
    id: 'js-215',
    question: "üìù What's the output?\n\n```javascript\nasync function test() {\n  throw new Error('Oops!');\n}\n\ntest()\n  .then(() => console.log('Success'))\n  .catch(err => console.log('Error:', err.message));\n```",
    category: 'javascript',
    subcategory: 'async-await',
    difficulty: 'medium',
    options: [
      'Success',
      'Error: Oops!',
      'Uncaught Error',
      'undefined',
    ],
    correctAnswer: 1,
    explanation: "Throwing an error in an async function is equivalent to returning a rejected Promise. The error is caught by the .catch() handler, which logs 'Error: Oops!'.",
    tags: ['async', 'await', 'error-handling'],
  },

{
    id: 'js-216',
    question: "üìù What's the output?\n\n```javascript\nconst promise = new Promise(resolve => {\n  console.log('1');\n  resolve('2');\n});\n\nasync function test() {\n  console.log('3');\n  const result = await promise;\n  console.log(result);\n}\n\nconsole.log('4');\ntest();\nconsole.log('5');\n```",
    category: 'javascript',
    subcategory: 'async-await',
    difficulty: 'hard',
    options: [
      '1 4 3 5 2',
      '4 1 3 5 2',
      '1 4 5 3 2',
      '4 3 1 5 2',
    ],
    correctAnswer: 0,
    explanation: "**Async/await and the event loop** - like a chef multitasking in a kitchen!\n\n**Think of it like cooking:**\n- Synchronous code = preparing ingredients (do it NOW)\n- Async code = waiting for oven timer (do other things while waiting)\n- Microtask queue = urgent tasks that jump the line\n\n**Step-by-step execution:**\n\n**Phase 1: Promise constructor runs immediately (synchronous!)**\n```javascript\nconst promise = new Promise(resolve => {\n  console.log('1');  // ‚Üê Executes IMMEDIATELY\n  resolve('2');\n});\n// Promise constructor is NOT async - it runs right away!\n```\n\n**Phase 2: Sync code before function call**\n```javascript\nconsole.log('4');  // ‚Üê Executes\n```\n\n**Phase 3: test() function starts**\n```javascript\ntest();\n  ‚Üì\nfunction test() {\n  console.log('3');  // ‚Üê Executes (synchronous part)\n  await promise;     // ‚Üê PAUSES here, returns to caller\n  // '2' is scheduled in microtask queue\n}\n```\n\n**Phase 4: Continue sync code**\n```javascript\nconsole.log('5');  // ‚Üê Executes\n```\n\n**Phase 5: Call stack empty, process microtask queue**\n```javascript\n// Microtask: Resume test() function\nconsole.log(result);  // ‚Üê '2'\n```\n\n**Timeline:**\n```\n0ms: Promise executor runs ‚Üí logs '1'\n0ms: Promise resolves with '2' (queued in microtasks)\n0ms: console.log('4') ‚Üí logs '4'\n0ms: test() called ‚Üí logs '3'\n0ms: await promise ‚Üí function pauses, returns Promise\n0ms: console.log('5') ‚Üí logs '5'\n0ms: Call stack empty!\n1ms: Microtask queue processes ‚Üí resumes test() ‚Üí logs '2'\n\nFinal output: 1 4 3 5 2\n```\n\n**Visual breakdown:**\n```javascript\n// Execution order:\n\nconst promise = new Promise(...)  // [1] Constructor runs immediately\nconsole.log('1')                   // Logs: 1\n\nconsole.log('4')                   // [2] Sync code\n                                   // Logs: 4\n\ntest()                            // [3] Function called\nconsole.log('3')                   // Logs: 3\nawait promise                      // [4] Pauses, schedules microtask\n// Function yields control here\n\nconsole.log('5')                   // [5] Continues sync code\n                                   // Logs: 5\n\n// [6] Call stack empty, process microtasks\nconsole.log(result)                // Logs: 2\n```\n\n**Key insights:**\n\n**1. Promise constructors run immediately**\n```javascript\n// This is SYNCHRONOUS!\nnew Promise(resolve => {\n  console.log('Runs NOW');  // Not async!\n  resolve();\n});\n```\n\n**2. await pauses the function, not the program**\n```javascript\nasync function example() {\n  console.log('Before');  // Runs\n  await something();      // Pauses THIS function\n  console.log('After');   // Waits\n}\n\nexample();\nconsole.log('Outside');  // Runs BEFORE 'After'\n// Output: Before, Outside, After\n```\n\n**3. Microtasks run before next task**\n```javascript\nconsole.log('1');          // Sync\nsetTimeout(() => {         // Task queue (macro)\n  console.log('2');\n}, 0);\nPromise.resolve().then(() => {  // Microtask queue\n  console.log('3');\n});\nconsole.log('4');          // Sync\n\n// Output: 1, 4, 3, 2\n// Microtasks (3) run before tasks (2)!\n```\n\n**Common gotcha:**\n```javascript\n// People expect this order:\n// '1' ‚Üí '3' ‚Üí '2' ‚Üí '4' ‚Üí '5'\n\n// But Promise constructor runs IMMEDIATELY:\n// '1' ‚Üí '4' ‚Üí '3' ‚Üí '5' ‚Üí '2'\n```\n\n**Real-world analogy:**\n```javascript\n// Restaurant kitchen:\nconst order = new Promise(resolve => {\n  console.log('Taking order');    // Waiter writes it down NOW\n  resolve('Pizza');\n});\n\nasync function cook() {\n  console.log('Start cooking');   // Start prep\n  const food = await order;       // Wait for order ticket\n  console.log('Serve', food);     // Serve when ready\n}\n\nconsole.log('Open kitchen');\ncook();\nconsole.log('Take more orders');\n\n// Output:\n// Taking order (order written)\n// Open kitchen (opening tasks)\n// Start cooking (begin prep)\n// Take more orders (don't wait!)\n// Serve Pizza (after microtask)\n```\n\n**Memory trick:**\n- Promise constructor = **NOW**\n- await = **PAUSE** this function\n- Microtasks = **NEXT** (before setTimeout)\n- Sync code never waits for async!",
    tags: ['async', 'await', 'event-loop'],
  },

{
    id: 'js-217',
    question: "üìù What's the output?\n\n```javascript\nasync function test() {\n  return await 'Hello';\n}\n\ntest().then(console.log);\n```",
    category: 'javascript',
    subcategory: 'async-await',
    difficulty: 'easy',
    options: [
      'Promise {<fulfilled>: "Hello"}',
      'Hello',
      'undefined',
      'Error',
    ],
    correctAnswer: 1,
    explanation: "You can await non-Promise values. JavaScript automatically wraps 'Hello' in Promise.resolve('Hello'), then awaits it. The value 'Hello' is returned and logged by .then().",
    tags: ['async', 'await'],
  },

{
    id: 'js-218',
    question: "üìù What happens?\n\n```javascript\nasync function test() {\n  await Promise.reject('Error');\n  console.log('This line');\n}\n\ntest();\n```",
    category: 'javascript',
    subcategory: 'async-await',
    difficulty: 'medium',
    options: [
      'Logs "This line"',
      'Unhandled Promise rejection, "This line" never logs',
      'Logs undefined',
      'SyntaxError',
    ],
    correctAnswer: 1,
    explanation: "When a Promise is rejected and not caught, the async function returns a rejected Promise. 'This line' never executes because the error stops execution. This results in an unhandled Promise rejection.",
    tags: ['async', 'await', 'error-handling'],
  },

{
    id: 'js-219',
    question: "üìù What's the output?\n\n```javascript\nasync function* generator() {\n  yield await Promise.resolve(1);\n  yield await Promise.resolve(2);\n}\n\n(async () => {\n  for await (const num of generator()) {\n    console.log(num);\n  }\n})();\n```",
    category: 'javascript',
    subcategory: 'async-await',
    difficulty: 'hard',
    options: [
      '1 2',
      'Promise Promise',
      'undefined undefined',
      'SyntaxError',
    ],
    correctAnswer: 0,
    explanation: "**Async generators = generators that can yield Promises!** Like a vending machine that takes time to prepare each item.\n\n**What happens:**\n```javascript\nasync function* generator() {\n  yield await Promise.resolve(1);  // Pause, wait, yield 1\n  yield await Promise.resolve(2);  // Pause, wait, yield 2\n}\n\nfor await (const num of generator()) {\n  console.log(num);  // Logs: 1, then 2\n}\n```\n\n**Step-by-step:**\n```\n1. for await...of calls generator.next()\n   ‚Üí Executes until first yield\n   ‚Üí await Promise.resolve(1) ‚Üí gets 1\n   ‚Üí Yields 1\n   ‚Üí Loop receives 1, logs it\n\n2. Loop calls generator.next() again\n   ‚Üí Executes until second yield\n   ‚Üí await Promise.resolve(2) ‚Üí gets 2\n   ‚Üí Yields 2\n   ‚Üí Loop receives 2, logs it\n\n3. Generator done\n   ‚Üí Loop exits\n```\n\n**Regular generator vs Async generator:**\n```javascript\n// Regular generator (sync)\nfunction* syncGen() {\n  yield 1;\n  yield 2;\n}\n\nfor (const num of syncGen()) {\n  console.log(num);  // 1, 2\n}\n\n// Async generator\nasync function* asyncGen() {\n  yield await Promise.resolve(1);\n  yield await Promise.resolve(2);\n}\n\nfor await (const num of asyncGen()) {\n  console.log(num);  // 1, 2 (waits for Promises)\n}\n```\n\n**Real-world use case:**\n```javascript\n// Paginated API fetching\nasync function* fetchPages(url) {\n  let page = 1;\n  while (true) {\n    const response = await fetch(`${url}?page=${page}`);\n    const data = await response.json();\n    \n    if (data.items.length === 0) break;\n    \n    yield data.items;  // Yield each page\n    page++;\n  }\n}\n\n// Usage:\nfor await (const items of fetchPages('/api/users')) {\n  console.log(items);  // Process each page as it arrives\n}\n```\n\n**Memory trick:** \n- `function*` = generator (yields values)\n- `async function*` = async generator (yields Promises)\n- `for await...of` = loop that waits for each Promise",
    tags: ['async', 'await', 'generators', 'iterators'],
  },

{
    id: 'js-220',
    question: "üìù What's the difference?\n\n```javascript\n// Version 1\nconst result = await fetch('/api').then(r => r.json());\n\n// Version 2\nconst response = await fetch('/api');\nconst result = await response.json();\n```",
    category: 'javascript',
    subcategory: 'async-await',
    difficulty: 'medium',
    options: [
      'Version 1 is faster',
      'Version 2 is faster',
      'Functionally identical, same performance',
      'Version 1 has better error handling',
    ],
    correctAnswer: 2,
    explanation: "Both versions are functionally identical with the same performance. Version 1 chains .then() to the Promise before awaiting the final result. Version 2 awaits each step separately. Both wait for the same operations in the same order.",
    tags: ['async', 'await', 'promises'],
  },

{
    id: 'js-221',
    question: "üìù What's the output?\n\n```javascript\nasync function test() {\n  console.log('Start');\n  await undefined;\n  console.log('End');\n}\n\ntest();\nconsole.log('Outside');\n```",
    category: 'javascript',
    subcategory: 'async-await',
    difficulty: 'medium',
    options: [
      'Start End Outside',
      'Start Outside End',
      'Outside Start End',
      'Start Outside (End never logs)',
    ],
    correctAnswer: 1,
    explanation: "Awaiting undefined wraps it in Promise.resolve(undefined) and pauses execution. 'Start' logs first, then the function yields. 'Outside' logs (sync). Then the microtask runs, resuming the async function and logging 'End'.",
    tags: ['async', 'await', 'event-loop'],
  },

{
    id: 'js-222',
    question: "üìù How can you run async functions in parallel?\n\n```javascript\nconst urls = ['/api/1', '/api/2', '/api/3'];\n```",
    category: 'javascript',
    subcategory: 'async-await',
    difficulty: 'medium',
    options: [
      'urls.forEach(async url => await fetch(url))',
      'for (const url of urls) { await fetch(url) }',
      'await Promise.all(urls.map(url => fetch(url)))',
      'urls.map(async url => await fetch(url))',
    ],
    correctAnswer: 2,
    explanation: "**Only Promise.all() correctly runs in parallel and waits for all!**\n\n**Option A/D - Fire and forget (doesn't wait):**\n```javascript\nurls.forEach(async url => await fetch(url));\nurls.map(async url => await fetch(url));\n// Starts all, but doesn't wait! Returns immediately\n```\n\n**Option B - Sequential (one at a time):**\n```javascript\nfor (const url of urls) {\n  await fetch(url);  // Waits for each before starting next\n}\n// Slow! 3 URLs = 3x time\n```\n\n**Option C - Parallel + Wait (CORRECT):**\n```javascript\nawait Promise.all(urls.map(url => fetch(url)));\n// Starts all at once, waits for all to finish\n```\n\n**Why it matters:**\n```javascript\n// ‚ùå forEach doesn't wait\nconst results = [];\nurls.forEach(async url => {\n  const data = await fetch(url);\n  results.push(data);\n});\nconsole.log(results);  // [] (empty! didn't wait)\n\n// ‚úÖ Promise.all waits\nconst results = await Promise.all(\n  urls.map(url => fetch(url))\n);\nconsole.log(results);  // [data1, data2, data3]\n```\n\n**Memory trick:** Promise.all() = \"Start all, wait for all\".",
    tags: ['async', 'await', 'promises', 'arrays'],
  },

{
    id: 'js-223',
    question: "üìù What's the output?\n\n```javascript\nasync function test() {\n  try {\n    return 'Success';\n  } finally {\n    return 'Finally';\n  }\n}\n\ntest().then(console.log);\n```",
    category: 'javascript',
    subcategory: 'async-await',
    difficulty: 'hard',
    options: [
      'Success',
      'Finally',
      'undefined',
      'Error',
    ],
    correctAnswer: 1,
    explanation: "**finally block returns overwrite everything** - like a last-minute plot twist!\n\n**Think of it like email drafts:**\n- try block = Draft #1\n- catch block = Draft #2 (if error)\n- finally block = \"Actually, send THIS instead!\" (overwrites everything)\n\n**What happens:**\n```javascript\nasync function test() {\n  try {\n    return 'Success';  // ‚Üê Prepared to return this\n  } finally {\n    return 'Finally';  // ‚Üê NOPE! Return this instead!\n  }\n}\n\ntest().then(console.log);  // 'Finally'\n```\n\n**Step-by-step:**\n```\n1. try block executes\n   ‚Üí Prepares to return 'Success'\n   ‚Üí But wait! finally block exists\n   \n2. finally block ALWAYS runs\n   ‚Üí Returns 'Finally'\n   ‚Üí This OVERWRITES 'Success'\n   \n3. Promise resolves with 'Finally'\n```\n\n**The rule: finally return > try return > catch return**\n\n```javascript\n// Example 1: finally overwrites try\nasync function test1() {\n  try {\n    return 'try';\n  } finally {\n    return 'finally';  // Wins!\n  }\n}\ntest1().then(console.log);  // 'finally'\n\n// Example 2: finally overwrites catch\nasync function test2() {\n  try {\n    throw new Error();\n  } catch {\n    return 'catch';\n  } finally {\n    return 'finally';  // Still wins!\n  }\n}\ntest2().then(console.log);  // 'finally'\n\n// Example 3: No return in finally = doesn't overwrite\nasync function test3() {\n  try {\n    return 'try';\n  } finally {\n    console.log('cleanup');  // No return!\n  }\n}\ntest3().then(console.log);  // 'try' (not overwritten)\n```\n\n**Visual flow:**\n```javascript\nasync function test() {\n  try {\n    return 'Success';  // [1] Queued for return\n  } finally {\n    return 'Finally';  // [2] Overwrites [1]\n  }\n}\n\n// What JavaScript does:\nStep 1: Enter try block\nStep 2: \"return 'Success'\" ‚Üí Save 'Success' as pending return\nStep 3: Enter finally block (ALWAYS runs)\nStep 4: \"return 'Finally'\" ‚Üí REPLACE pending return with 'Finally'\nStep 5: Exit function with 'Finally'\n```\n\n**With errors:**\n```javascript\nasync function test() {\n  try {\n    throw new Error('Oops');\n  } catch (err) {\n    return 'Caught';\n  } finally {\n    return 'Finally';  // Overwrites 'Caught'\n  }\n}\n\ntest().then(console.log);  // 'Finally' (not 'Caught')\n```\n\n**Why is this dangerous?**\n```javascript\n// ‚ùå Bad: Hides errors!\nasync function fetchData() {\n  try {\n    const data = await fetch('/api');\n    return data;\n  } catch (error) {\n    throw error;  // Want to propagate error\n  } finally {\n    return null;  // OOPS! Overwrites error, no error thrown!\n  }\n}\n\n// The error is swallowed! Function returns null instead of throwing.\n```\n\n**Best practice: Don't return in finally**\n```javascript\n// ‚úÖ Good: Use finally for cleanup only\nasync function fetchData() {\n  try {\n    const data = await fetch('/api');\n    return data;\n  } catch (error) {\n    throw error;\n  } finally {\n    console.log('Cleanup');  // No return!\n    // Close connections, clear timers, etc.\n  }\n}\n```\n\n**Real-world example:**\n```javascript\nasync function processFile() {\n  const file = openFile('data.txt');\n  try {\n    const result = await processData(file);\n    return result;  // Success case\n  } catch (error) {\n    throw error;  // Error case\n  } finally {\n    file.close();  // ALWAYS close file\n    // ‚úÖ No return here - let try/catch handle returns\n  }\n}\n```\n\n**Comparison with regular functions:**\n```javascript\n// Works the same in non-async functions!\nfunction test() {\n  try {\n    return 'try';\n  } finally {\n    return 'finally';  // Overwrites\n  }\n}\n\ntest();  // 'finally'\n```\n\n**The finally return hierarchy:**\n```\n1. finally return (HIGHEST priority - overwrites all)\n2. catch return (overwritten by finally)\n3. try return (overwritten by catch or finally)\n4. No return (undefined)\n```\n\n**Common gotcha - even throw is overwritten:**\n```javascript\nasync function test() {\n  try {\n    throw new Error('Error!');\n  } finally {\n    return 'Finally';  // Swallows the error!\n  }\n}\n\ntest()\n  .then(console.log)   // Logs: 'Finally'\n  .catch(console.log); // Never runs! Error was swallowed\n```\n\n**Memory trick:**\n- finally = \"Final word\" - always gets the last say\n- finally return = \"Nevermind everything else, return THIS!\"\n- Use finally for cleanup, not returns\n- Returning in finally usually hides bugs!",
    tags: ['async', 'await', 'error-handling'],
  },
];
