import { QuizQuestion } from '../../types/quiz';

export const async_awaitQuizzes: QuizQuestion[] = [
{
    id: 'js-209',
    question: "üìù What's the output?\n\n```javascript\nasync function test() {\n  return 'Hello';\n}\n\nconsole.log(test());\n```",
    category: 'javascript',
    subcategory: 'async-await',
    difficulty: 'easy',
    options: [
      'Hello',
      'Promise {<fulfilled>: "Hello"}',
      'undefined',
      'Promise {<pending>}',
    ],
    correctAnswer: 1,
    explanation: "Async functions always return a Promise, even if you return a non-Promise value. The value 'Hello' is automatically wrapped in a resolved Promise. To get the actual value, you need to use .then() or await.",
    tags: ['async', 'await', 'promises'],
  },

{
    id: 'js-210',
    question: "üìù What's the output?\n\n```javascript\nasync function getData() {\n  return await Promise.resolve('Data');\n}\n\ngetData().then(result => console.log(result));\n```",
    category: 'javascript',
    subcategory: 'async-await',
    difficulty: 'easy',
    options: [
      'Promise {<fulfilled>: "Data"}',
      'Data',
      'undefined',
      'Error',
    ],
    correctAnswer: 1,
    explanation: "The await keyword waits for the Promise to resolve and returns the resolved value ('Data'). The async function then wraps this in a new Promise, which is handled by .then(), logging 'Data'.",
    tags: ['async', 'await', 'promises'],
  },

{
    id: 'js-211',
    question: "üìù What's the output?\n\n```javascript\nasync function test() {\n  console.log('1');\n  await Promise.resolve();\n  console.log('2');\n}\n\ntest();\nconsole.log('3');\n```",
    category: 'javascript',
    subcategory: 'async-await',
    difficulty: 'medium',
    options: [
      '1 2 3',
      '1 3 2',
      '3 1 2',
      '1 2 3 or 1 3 2 (unpredictable)',
    ],
    correctAnswer: 1,
    explanation: "'1' logs first (synchronous). When await is encountered, the async function pauses and returns control to the caller. '3' logs next (synchronous). Then the microtask queue runs, resuming the async function and logging '2'.",
    tags: ['async', 'await', 'event-loop'],
  },

{
    id: 'js-212',
    question: "üìù What's the output?\n\n```javascript\nasync function test() {\n  try {\n    await Promise.reject('Error!');\n  } catch (err) {\n    return 'Caught';\n  }\n}\n\ntest().then(result => console.log(result));\n```",
    category: 'javascript',
    subcategory: 'async-await',
    difficulty: 'medium',
    options: [
      'Error!',
      'Caught',
      'undefined',
      'Uncaught Error',
    ],
    correctAnswer: 1,
    explanation: "When a Promise is rejected in an async function, it throws an error that can be caught with try/catch. The catch block returns 'Caught', which becomes the resolved value of the Promise returned by test().",
    tags: ['async', 'await', 'error-handling'],
  },

{
    id: 'js-213',
    question: "üìù What's the output?\n\n```javascript\nasync function test() {\n  const p1 = Promise.resolve('First');\n  const p2 = Promise.resolve('Second');\n  \n  const r1 = await p1;\n  const r2 = await p2;\n  \n  console.log(r1, r2);\n}\n\ntest();\n```",
    category: 'javascript',
    subcategory: 'async-await',
    difficulty: 'easy',
    options: [
      'First Second',
      'Promise Promise',
      'undefined undefined',
      'Error',
    ],
    correctAnswer: 0,
    explanation: "Each await waits for the Promise to resolve and returns the value. Since both Promises are already resolved, r1 gets 'First' and r2 gets 'Second', both log immediately.",
    tags: ['async', 'await', 'promises'],
  },

{
    id: 'js-214',
    question: "üìù Which runs faster?\n\n```javascript\n// Option A\nasync function optionA() {\n  const a = await fetch('/api/a');\n  const b = await fetch('/api/b');\n  return [a, b];\n}\n\n// Option B\nasync function optionB() {\n  const [a, b] = await Promise.all([\n    fetch('/api/a'),\n    fetch('/api/b')\n  ]);\n  return [a, b];\n}\n```",
    category: 'javascript',
    subcategory: 'async-await',
    difficulty: 'medium',
    options: [
      'Option A is faster',
      'Option B is faster',
      'Same speed',
      'Depends on network',
    ],
    correctAnswer: 1,
    explanation: "Option B is faster. Option A waits for /api/a to complete before starting /api/b (sequential). Option B starts both requests simultaneously using Promise.all() and waits for both to complete (parallel), making it roughly 2x faster.",
    tags: ['async', 'await', 'promises', 'performance'],
  },

{
    id: 'js-215',
    question: "üìù What's the output?\n\n```javascript\nasync function test() {\n  throw new Error('Oops!');\n}\n\ntest()\n  .then(() => console.log('Success'))\n  .catch(err => console.log('Error:', err.message));\n```",
    category: 'javascript',
    subcategory: 'async-await',
    difficulty: 'medium',
    options: [
      'Success',
      'Error: Oops!',
      'Uncaught Error',
      'undefined',
    ],
    correctAnswer: 1,
    explanation: "Throwing an error in an async function is equivalent to returning a rejected Promise. The error is caught by the .catch() handler, which logs 'Error: Oops!'.",
    tags: ['async', 'await', 'error-handling'],
  },

{
    id: 'js-216',
    question: "üìù What's the output?\n\n```javascript\nconst promise = new Promise(resolve => {\n  console.log('1');\n  resolve('2');\n});\n\nasync function test() {\n  console.log('3');\n  const result = await promise;\n  console.log(result);\n}\n\nconsole.log('4');\ntest();\nconsole.log('5');\n```",
    category: 'javascript',
    subcategory: 'async-await',
    difficulty: 'hard',
    options: [
      '1 4 3 5 2',
      '4 1 3 5 2',
      '1 4 5 3 2',
      '4 3 1 5 2',
    ],
    correctAnswer: 0,
    explanation: "Promise executor runs immediately: '1'. Then '4' (sync). test() is called: '3' logs, await pauses. '5' logs (sync). Microtask queue runs: '2' logs. Order: 1 4 3 5 2.",
    tags: ['async', 'await', 'event-loop'],
  },

{
    id: 'js-217',
    question: "üìù What's the output?\n\n```javascript\nasync function test() {\n  return await 'Hello';\n}\n\ntest().then(console.log);\n```",
    category: 'javascript',
    subcategory: 'async-await',
    difficulty: 'easy',
    options: [
      'Promise {<fulfilled>: "Hello"}',
      'Hello',
      'undefined',
      'Error',
    ],
    correctAnswer: 1,
    explanation: "You can await non-Promise values. JavaScript automatically wraps 'Hello' in Promise.resolve('Hello'), then awaits it. The value 'Hello' is returned and logged by .then().",
    tags: ['async', 'await'],
  },

{
    id: 'js-218',
    question: "üìù What happens?\n\n```javascript\nasync function test() {\n  await Promise.reject('Error');\n  console.log('This line');\n}\n\ntest();\n```",
    category: 'javascript',
    subcategory: 'async-await',
    difficulty: 'medium',
    options: [
      'Logs "This line"',
      'Unhandled Promise rejection, "This line" never logs',
      'Logs undefined',
      'SyntaxError',
    ],
    correctAnswer: 1,
    explanation: "When a Promise is rejected and not caught, the async function returns a rejected Promise. 'This line' never executes because the error stops execution. This results in an unhandled Promise rejection.",
    tags: ['async', 'await', 'error-handling'],
  },

{
    id: 'js-219',
    question: "üìù What's the output?\n\n```javascript\nasync function* generator() {\n  yield await Promise.resolve(1);\n  yield await Promise.resolve(2);\n}\n\n(async () => {\n  for await (const num of generator()) {\n    console.log(num);\n  }\n})();\n```",
    category: 'javascript',
    subcategory: 'async-await',
    difficulty: 'hard',
    options: [
      '1 2',
      'Promise Promise',
      'undefined undefined',
      'SyntaxError',
    ],
    correctAnswer: 0,
    explanation: "Async generators (async function*) can yield Promises. for await...of iterates over the async generator, waiting for each Promise to resolve. This logs 1, then 2.",
    tags: ['async', 'await', 'generators', 'iterators'],
  },

{
    id: 'js-220',
    question: "üìù What's the difference?\n\n```javascript\n// Version 1\nconst result = await fetch('/api').then(r => r.json());\n\n// Version 2\nconst response = await fetch('/api');\nconst result = await response.json();\n```",
    category: 'javascript',
    subcategory: 'async-await',
    difficulty: 'medium',
    options: [
      'Version 1 is faster',
      'Version 2 is faster',
      'Functionally identical, same performance',
      'Version 1 has better error handling',
    ],
    correctAnswer: 2,
    explanation: "Both versions are functionally identical with the same performance. Version 1 chains .then() to the Promise before awaiting the final result. Version 2 awaits each step separately. Both wait for the same operations in the same order.",
    tags: ['async', 'await', 'promises'],
  },

{
    id: 'js-221',
    question: "üìù What's the output?\n\n```javascript\nasync function test() {\n  console.log('Start');\n  await undefined;\n  console.log('End');\n}\n\ntest();\nconsole.log('Outside');\n```",
    category: 'javascript',
    subcategory: 'async-await',
    difficulty: 'medium',
    options: [
      'Start End Outside',
      'Start Outside End',
      'Outside Start End',
      'Start Outside (End never logs)',
    ],
    correctAnswer: 1,
    explanation: "Awaiting undefined wraps it in Promise.resolve(undefined) and pauses execution. 'Start' logs first, then the function yields. 'Outside' logs (sync). Then the microtask runs, resuming the async function and logging 'End'.",
    tags: ['async', 'await', 'event-loop'],
  },

{
    id: 'js-222',
    question: "üìù How can you run async functions in parallel?\n\n```javascript\nconst urls = ['/api/1', '/api/2', '/api/3'];\n```",
    category: 'javascript',
    subcategory: 'async-await',
    difficulty: 'medium',
    options: [
      'urls.forEach(async url => await fetch(url))',
      'for (const url of urls) { await fetch(url) }',
      'await Promise.all(urls.map(url => fetch(url)))',
      'urls.map(async url => await fetch(url))',
    ],
    correctAnswer: 2,
    explanation: "Promise.all() runs all Promises in parallel and waits for all to complete. Option A/D start parallel but don't wait. Option B runs sequentially (one at a time). Only Promise.all() properly runs in parallel and collects all results.",
    tags: ['async', 'await', 'promises', 'arrays'],
  },

{
    id: 'js-223',
    question: "üìù What's the output?\n\n```javascript\nasync function test() {\n  try {\n    return 'Success';\n  } finally {\n    return 'Finally';\n  }\n}\n\ntest().then(console.log);\n```",
    category: 'javascript',
    subcategory: 'async-await',
    difficulty: 'hard',
    options: [
      'Success',
      'Finally',
      'undefined',
      'Error',
    ],
    correctAnswer: 1,
    explanation: "The finally block executes after try/catch, and its return value overwrites any previous return value. Even though try returns 'Success', the finally block's return 'Finally' overwrites it, so 'Finally' is what the Promise resolves to.",
    tags: ['async', 'await', 'error-handling'],
  },
];
