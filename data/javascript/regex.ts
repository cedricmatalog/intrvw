import { QuizQuestion } from '../../types/quiz';

export const regexQuizzes: QuizQuestion[] = [
{
    id: 'js-224',
    question: "üìù What's the output?\n\n```javascript\nconst regex = /hello/;\nconsole.log(regex.test('hello world'));\nconsole.log(regex.test('Hello world'));\n```",
    category: 'javascript',
    subcategory: 'regex',
    difficulty: 'easy',
    options: [
      'true true',
      'true false',
      'false false',
      'false true',
    ],
    correctAnswer: 1,
    explanation: "**Regex is case-sensitive by default** - 'hello' ‚â† 'Hello' without the 'i' flag!\n\n**Think of regex like a strict spell-checker** - without the 'i' flag, it's picky about uppercase vs lowercase!\n\n**What happens:**\n```javascript\nconst regex = /hello/;  // No 'i' flag = case-sensitive\n\nregex.test('hello world');  // true ‚úÖ (exact match)\nregex.test('Hello world');  // false ‚ùå (capital H!)\n```\n\n**Case-sensitive vs case-insensitive:**\n```javascript\n// Case-sensitive (default):\nconst strict = /hello/;\nstrict.test('hello');  // true ‚úÖ\nstrict.test('Hello');  // false ‚ùå\nstrict.test('HELLO');  // false ‚ùå\n\n// Case-insensitive ('i' flag):\nconst flexible = /hello/i;\nflexible.test('hello');  // true ‚úÖ\nflexible.test('Hello');  // true ‚úÖ\nflexible.test('HELLO');  // true ‚úÖ\n```\n\n**Common regex flags:**\n```javascript\n// i = case-insensitive:\n/hello/i.test('HeLLo');  // true\n\n// g = global (find all matches):\n'cat bat'.match(/at/g);  // ['at', 'at']\n\n// m = multiline (^ and $ match line boundaries):\n/^hello/m.test('world\\nhello');  // true\n\n// Combine flags:\n/hello/gi;  // global + case-insensitive\n```\n\n**Memory trick:** No 'i' flag = case-sensitive, exact match required!",
    tags: ['regex', 'patterns'],
  },

{
    id: 'js-225',
    question: "üìù What does the 'g' flag do?\n\n```javascript\nconst text = 'cat bat cat';\nconst regex1 = /cat/;\nconst regex2 = /cat/g;\n\nconsole.log(text.match(regex1));\nconsole.log(text.match(regex2));\n```",
    category: 'javascript',
    subcategory: 'regex',
    difficulty: 'easy',
    options: [
      "['cat'] and ['cat']",
      "['cat', index: 0] and ['cat', 'cat']",
      "Both return ['cat', 'cat']",
      "['cat'] and ['cat', 'cat']",
    ],
    correctAnswer: 1,
    explanation: "**'g' flag = global, finds ALL matches** - without it, match() only returns the first!\n\n**Think of 'g' like searching with 'Find All' vs 'Find Next'** - one finds everything, the other stops at first result!\n\n**What happens:**\n```javascript\nconst text = 'cat bat cat';\n\n// Without 'g' - first match only + metadata:\ntext.match(/cat/);\n// ['cat', index: 0, input: 'cat bat cat', groups: undefined]\n\n// With 'g' - all matches, no metadata:\ntext.match(/cat/g);\n// ['cat', 'cat'] ‚úÖ\n```\n\n**Comparison:**\n```javascript\nconst str = 'The dog and the dog';\n\n// No 'g' flag:\nstr.match(/dog/);\n// Result: ['dog', index: 4, input: '...', groups: undefined]\n// ‚Üí First match only\n// ‚Üí Includes metadata (index, input)\n\n// With 'g' flag:\nstr.match(/dog/g);\n// Result: ['dog', 'dog']\n// ‚Üí All matches\n// ‚Üí No metadata, just array of matches\n```\n\n**Global flag with other methods:**\n```javascript\nconst text = 'a1 b2 c3';\n\n// replace without 'g' - replaces first only:\ntext.replace(/\\d/, 'X');  // 'aX b2 c3'\n\n// replace with 'g' - replaces all:\ntext.replace(/\\d/g, 'X');  // 'aX bX cX'\n\n// test() with 'g' - maintains lastIndex:\nconst regex = /cat/g;\nregex.test('cat cat');  // true (finds first)\nregex.test('cat cat');  // true (finds second)\nregex.test('cat cat');  // false (no more)\n```\n\n**Memory trick:** 'g' = global = find all, no 'g' = first only + metadata!",
    tags: ['regex', 'flags', 'string-methods'],
  },

{
    id: 'js-226',
    question: "üìù What's the output?\n\n```javascript\nconst regex = /\\d+/;\nconsole.log(regex.test('abc123'));\nconsole.log(regex.test('abcdef'));\n```",
    category: 'javascript',
    subcategory: 'regex',
    difficulty: 'easy',
    options: [
      'true true',
      'true false',
      'false true',
      'false false',
    ],
    correctAnswer: 1,
    explanation: "**\\d matches digits, + means one or more** - together they find number sequences!\n\n**Think of \\d+ like a metal detector** - it beeps (matches) when it finds one or more pieces of metal (digits)!\n\n**What happens:**\n```javascript\nconst regex = /\\d+/;\n\nregex.test('abc123');  // true ‚úÖ ('123' = digits!)\nregex.test('abcdef');  // false ‚ùå (no digits)\n```\n\n**Common quantifiers:**\n```javascript\n// + = one or more:\n/\\d+/.test('123');   // true (3 digits)\n/\\d+/.test('');      // false (zero digits)\n\n// * = zero or more:\n/\\d*/.test('123');   // true (3 digits)\n/\\d*/.test('');      // true (zero digits OK!)\n\n// ? = zero or one:\n/\\d?/.test('1');     // true (one digit)\n/\\d?/.test('');      // true (zero digits OK!)\n/\\d?/.test('123');   // true (matches first digit)\n\n// {n} = exactly n:\n/\\d{3}/.test('123'); // true (exactly 3)\n/\\d{3}/.test('12');  // false (only 2)\n\n// {n,m} = between n and m:\n/\\d{2,4}/.test('1');    // false (only 1)\n/\\d{2,4}/.test('123');  // true (3 is between 2-4)\n```\n\n**Character classes with quantifiers:**\n```javascript\n// \\d+ = one or more digits:\n/\\d+/.test('hello123');  // true\n\n// \\w+ = one or more word chars (letters, digits, _):\n/\\w+/.test('hello_123');  // true\n\n// \\s+ = one or more whitespace:\n/\\s+/.test('   ');  // true\n\n// . + = one or more any character:\n/.+/.test('anything');  // true\n```\n\n**Memory trick:** \\d = digit, + = one or more, together = find numbers!",
    tags: ['regex', 'patterns', 'quantifiers'],
  },

{
    id: 'js-227',
    question: "üìù What's the output?\n\n```javascript\nconst regex = /^hello$/;\nconsole.log(regex.test('hello'));\nconsole.log(regex.test('hello world'));\nconsole.log(regex.test('say hello'));\n```",
    category: 'javascript',
    subcategory: 'regex',
    difficulty: 'medium',
    options: [
      'true true true',
      'true false false',
      'false false false',
      'true true false',
    ],
    correctAnswer: 1,
    explanation: "**^ = start anchor, $ = end anchor** - together they require EXACT match!\n\n**Think of ^hello$ like a strict bouncer** - the password must be EXACTLY 'hello', nothing more, nothing less!\n\n**What happens:**\n```javascript\nconst regex = /^hello$/;\n\nregex.test('hello');       // true ‚úÖ (exact match!)\nregex.test('hello world'); // false ‚ùå (extra after)\nregex.test('say hello');   // false ‚ùå (extra before)\n```\n\n**Anchors explained:**\n```javascript\n// ^ = start of string:\n/^hello/.test('hello world');  // true ‚úÖ\n/^hello/.test('say hello');    // false ‚ùå\n\n// $ = end of string:\n/world$/.test('hello world');  // true ‚úÖ\n/world$/.test('world hello');  // false ‚ùå\n\n// Both = exact match:\n/^hello$/.test('hello');       // true ‚úÖ\n/^hello$/.test('hello!');      // false ‚ùå\n```\n\n**With vs without anchors:**\n```javascript\n// No anchors - matches anywhere:\n/cat/.test('concatenate');  // true (cat inside!)\n\n// Start anchor only:\n/^cat/.test('concatenate');  // false (doesn't start with cat)\n/^cat/.test('cat food');     // true (starts with cat)\n\n// End anchor only:\n/cat$/.test('concatenate');  // false (doesn't end with cat)\n/cat$/.test('my cat');       // true (ends with cat)\n\n// Both anchors - exact:\n/^cat$/.test('cat');         // true (exactly cat)\n/^cat$/.test('my cat');      // false (extra text)\n```\n\n**Practical examples:**\n```javascript\n// Exact 3-digit code:\n/^\\d{3}$/.test('123');    // true ‚úÖ\n/^\\d{3}$/.test('1234');   // false ‚ùå\n/^\\d{3}$/.test('a123');   // false ‚ùå\n\n// Email validation:\n/^\\w+@\\w+\\.\\w+$/.test('user@example.com');  // true\n/^\\w+@\\w+\\.\\w+$/.test('not an email');      // false\n```\n\n**Memory trick:** ^ = must start, $ = must end, both = exact match only!",
    tags: ['regex', 'anchors'],
  },

{
    id: 'js-228',
    question: "üìù What's the difference?\n\n```javascript\nconst regex1 = /./;\nconst regex2 = /\\./;\n\nconsole.log(regex1.test('a'));\nconsole.log(regex2.test('a'));\nconsole.log(regex2.test('.'));\n```",
    category: 'javascript',
    subcategory: 'regex',
    difficulty: 'medium',
    options: [
      'true true true',
      'true false true',
      'false false true',
      'true true false',
    ],
    correctAnswer: 1,
    explanation: "**. = wildcard (any char), \\. = literal period** - escaping changes meaning!\n\n**Think of . like a joker card** (matches anything) and **\\. like specifying the actual period card**!\n\n**What happens:**\n```javascript\nconst regex1 = /./;   // Dot = wildcard\nconst regex2 = /\\./;  // Escaped = literal period\n\nregex1.test('a');  // true ‚úÖ (any character!)\nregex2.test('a');  // false ‚ùå (looking for period)\nregex2.test('.');  // true ‚úÖ (literal period!)\n```\n\n**Dot wildcard behavior:**\n```javascript\n// . matches ANY single character (except newline):\n/./.test('a');     // true\n/./.test('1');     // true\n/./.test('!');     // true\n/./.test('@');     // true\n/./.test(' ');     // true\n/./.test('\\n');    // false (doesn't match newline)\n\n// Multiple dots:\n/.../.test('abc');  // true (matches 3 chars)\n/.../.test('ab');   // false (only 2 chars)\n```\n\n**Escaped dot for literal match:**\n```javascript\n// \\. matches only the period character:\n/\\./.test('.');     // true ‚úÖ\n/\\./.test('a');     // false ‚ùå\n/\\./.test('hello'); // false ‚ùå\n\n// Useful for file extensions:\n/\\.js$/.test('app.js');    // true\n/\\.js$/.test('app.ts');    // false\n\n// Email pattern:\n/\\w+@\\w+\\.com/.test('user@site.com');  // true\n```\n\n**Characters that need escaping:**\n```javascript\n// Special regex characters:\n// . * + ? ^ $ { } [ ] ( ) | \\\n\n// Without escaping (special meaning):\n/./      // Wildcard\n/*./     // Zero or more\n/+./     // One or more\n/^./     // Start anchor\n\n// With escaping (literal):\n/\\./     // Literal period\n/\\*/     // Literal asterisk\n/\\+/     // Literal plus\n/\\^/     // Literal caret\n```\n\n**Memory trick:** . = any character, \\. = literal period!",
    tags: ['regex', 'escaping'],
  },

{
    id: 'js-229',
    question: "üìù What's the output?\n\n```javascript\nconst regex = /[abc]/;\nconsole.log(regex.test('apple'));\nconsole.log(regex.test('banana'));\nconsole.log(regex.test('dog'));\n```",
    category: 'javascript',
    subcategory: 'regex',
    difficulty: 'easy',
    options: [
      'true true true',
      'true true false',
      'false false false',
      'true false true',
    ],
    correctAnswer: 1,
    explanation: "**[abc] = character class, matches ANY ONE of those characters** - like a whitelist!\n\n**Think of [abc] like a VIP list** - if your character is on the list (a, b, or c), you get in!\n\n**What happens:**\n```javascript\nconst regex = /[abc]/;\n\nregex.test('apple');   // true ‚úÖ (has 'a'!)\nregex.test('banana');  // true ‚úÖ (has 'a' and 'b'!)\nregex.test('dog');     // false ‚ùå (no a, b, or c)\n```\n\n**Character class patterns:**\n```javascript\n// [abc] - matches a, b, OR c:\n/[abc]/.test('apple');  // true (contains 'a')\n/[abc]/.test('zebra');  // true (contains 'b')\n/[abc]/.test('dog');    // false (no a, b, or c)\n\n// [0-9] - matches any digit:\n/[0-9]/.test('hello5');  // true\n/[0-9]/.test('hello');   // false\n\n// [a-z] - matches any lowercase letter:\n/[a-z]/.test('Hello');   // true (lowercase 'e', 'l', 'o')\n/[a-z]/.test('HELLO');   // false (no lowercase)\n\n// [A-Z] - matches any uppercase letter:\n/[A-Z]/.test('Hello');   // true (uppercase 'H')\n\n// Combined ranges:\n/[a-zA-Z0-9]/.test('@');  // false (not alphanumeric)\n/[a-zA-Z0-9]/.test('A');  // true\n```\n\n**Negated character class:**\n```javascript\n// [^abc] - matches anything EXCEPT a, b, c:\n/[^abc]/.test('a');     // false (is 'a'!)\n/[^abc]/.test('b');     // false (is 'b'!)\n/[^abc]/.test('d');     // true (not a, b, or c!)\n/[^abc]/.test('xyz');   // true (contains non-abc chars)\n\n// [^0-9] - matches non-digits:\n/[^0-9]/.test('5');     // false (is digit)\n/[^0-9]/.test('a');     // true (not digit)\n```\n\n**Character class shortcuts:**\n```javascript\n// \\d = [0-9] (digits):\n/\\d/.test('5');  // true\n\n// \\w = [a-zA-Z0-9_] (word characters):\n/\\w/.test('a');  // true\n/\\w/.test('_');  // true\n/\\w/.test('@');  // false\n\n// \\s = whitespace (space, tab, newline):\n/\\s/.test(' ');  // true\n```\n\n**Memory trick:** [abc] = any ONE of these, [^abc] = anything EXCEPT these!",
    tags: ['regex', 'character-classes'],
  },

{
    id: 'js-230',
    question: "üìù What does this regex match?\n\n```javascript\nconst regex = /\\w+@\\w+\\.\\w+/;\n```",
    category: 'javascript',
    subcategory: 'regex',
    difficulty: 'medium',
    options: [
      'Email addresses (basic pattern)',
      'URLs',
      'Phone numbers',
      'IP addresses',
    ],
    correctAnswer: 0,
    explanation: "**\\w+@\\w+\\.\\w+ matches basic email pattern** - word@word.word format!\n\n**What happens:**\n```javascript\nconst regex = /\\w+@\\w+\\.\\w+/;\n\n// Breakdown:\n// \\w+ = one or more word characters (letters, digits, _)\n// @   = literal @ symbol\n// \\w+ = one or more word characters (domain name)\n// \\.  = literal period (escaped!)\n// \\w+ = one or more word characters (extension)\n\nregex.test('user@example.com');  // true ‚úÖ\nregex.test('john_doe@site.org'); // true ‚úÖ\nregex.test('invalid.email');     // false ‚ùå (no @)\n```\n\n**Pattern breakdown:**\n```javascript\n// \\w = [a-zA-Z0-9_] (word characters)\n// + = one or more\n\n// So \\w+ matches:\n'user'     // ‚úÖ\n'john_123' // ‚úÖ\n'a'        // ‚úÖ\n''         // ‚ùå (need at least one)\n\n// Full pattern:\nuser  @  example  .  com\n\\w+   @  \\w+      \\.  \\w+\n```\n\n**Why this is basic:**\n```javascript\n// Matches valid emails:\n'simple@email.com'  // ‚úÖ\n'user123@site.org'  // ‚úÖ\n\n// But also matches invalid ones:\n'___@___.___'       // ‚úÖ (underscores only)\n'a@b.c'             // ‚úÖ (too short to be real)\n\n// Doesn't match some valid emails:\n'user+tag@site.com'     // ‚ùå (+ not in \\w)\n'user@mail.site.com'    // ‚ùå (subdomain)\n'user@site.co.uk'       // ‚ùå (multi-part extension)\n```\n\n**Memory trick:** \\w+@\\w+\\.\\w+ = basic email: word@word.word!",
    tags: ['regex', 'patterns'],
  },

{
    id: 'js-231',
    question: "üìù What's the output?\n\n```javascript\nconst regex = /a*/;\nconsole.log(regex.test(''));\nconsole.log(regex.test('aaa'));\nconsole.log(regex.test('bbb'));\n```",
    category: 'javascript',
    subcategory: 'regex',
    difficulty: 'medium',
    options: [
      'false true false',
      'true true true',
      'true true false',
      'false true true',
    ],
    correctAnswer: 1,
    explanation: "*** means zero or more** - even ZERO matches are valid!\n\n**Think of * like an optional buffet** - you can take as many items as you want, including zero!\n\n**What happens:**\n```javascript\nconst regex = /a*/;\n\nregex.test('');     // true ‚úÖ (zero a's OK!)\nregex.test('aaa');  // true ‚úÖ (three a's OK!)\nregex.test('bbb');  // true ‚úÖ (zero a's at start OK!)\n```\n\n**Why 'bbb' matches:**\n```javascript\n// /a*/ looks for zero or more 'a's\n// At the START of 'bbb', there are ZERO 'a's\n// Zero matches the pattern! (zero or more)\n\n'bbb'\n‚Üë zero 'a's here = match! ‚úÖ\n\n// test() returns true if pattern matches ANYWHERE\n```\n\n**Quantifier comparison:**\n```javascript\n// * = zero or more:\n/a*/.test('');     // true (zero OK)\n/a*/.test('a');    // true (one OK)\n/a*/.test('aaa');  // true (many OK)\n/a*/.test('bbb');  // true (zero at start OK)\n\n// + = one or more:\n/a+/.test('');     // false (need at least one!)\n/a+/.test('a');    // true (one OK)\n/a+/.test('aaa');  // true (many OK)\n/a+/.test('bbb');  // false (zero not OK!)\n\n// ? = zero or one:\n/a?/.test('');     // true (zero OK)\n/a?/.test('a');    // true (one OK)\n/a?/.test('aaa');  // true (matches first 'a')\n/a?/.test('bbb');  // true (zero OK)\n```\n\n**Practical use:**\n```javascript\n// Optional 's' for plurals:\n/cats*/.test('cat');   // true (zero s's)\n/cats*/.test('cats');  // true (one s)\n\n// Zero or more digits:\n/\\d*/.test('');     // true\n/\\d*/.test('123');  // true\n\n// Zero or more whitespace:\n/\\s*/.test('');     // true\n/\\s*/.test('   ');  // true\n```\n\n**Memory trick:** * = zero or more, even empty string matches!",
    tags: ['regex', 'quantifiers'],
  },

{
    id: 'js-232',
    question: "üìù What's the output?\n\n```javascript\nconst text = 'The price is $50 and $30';\nconst regex = /\\$(\\d+)/g;\nconst matches = text.match(regex);\nconsole.log(matches);\n```",
    category: 'javascript',
    subcategory: 'regex',
    difficulty: 'medium',
    options: [
      "['$50', '$30']",
      "['50', '30']",
      "[['$50', '50'], ['$30', '30']]",
      "['$', '$']",
    ],
    correctAnswer: 0,
    explanation: "**With 'g' flag, match() returns full matches only** - not capture groups!\n\n**What happens:**\n```javascript\nconst text = 'The price is $50 and $30';\nconst regex = /\\$(\\d+)/g;\n\ntext.match(regex);\n// ['$50', '$30'] ‚úÖ\n// Full matches only, capture groups ignored with 'g'!\n```\n\n**Global vs non-global with groups:**\n```javascript\nconst text = 'The price is $50 and $30';\n\n// Without 'g' - includes capture groups:\ntext.match(/\\$(\\d+)/);\n// ['$50', '50', index: 13, input: '...', groups: undefined]\n// [0] = full match: '$50'\n// [1] = capture group: '50'\n\n// With 'g' - only full matches:\ntext.match(/\\$(\\d+)/g);\n// ['$50', '$30']\n// No capture groups! Just all full matches\n```\n\n**Getting capture groups with 'g':**\n```javascript\nconst text = 'The price is $50 and $30';\nconst regex = /\\$(\\d+)/g;\n\n// Use matchAll() instead:\nconst matches = [...text.matchAll(regex)];\n// [\n//   ['$50', '50', index: 13, ...],\n//   ['$30', '30', index: 21, ...]\n// ]\n\nmatches[0][0];  // '$50' (full match)\nmatches[0][1];  // '50' (capture group)\nmatches[1][0];  // '$30'\nmatches[1][1];  // '30'\n```\n\n**Pattern breakdown:**\n```javascript\n// /\\$(\\d+)/g\n// \\$   = literal dollar sign (escaped)\n// (\\d+) = capture group: one or more digits\n// g     = global flag\n\n'$50'\n ‚Üë‚Üë\n ‚îÇ‚îî‚Üí Capture group (\\d+) = '50'\n ‚îî‚îÄ‚Üí Full match \\$(\\d+) = '$50'\n```\n\n**Memory trick:** match() + 'g' = all full matches, no capture groups!",
    tags: ['regex', 'groups', 'flags'],
  },

{
    id: 'js-233',
    question: "üìù What's the output?\n\n```javascript\nconst regex = /cat|dog/;\nconsole.log(regex.test('I have a cat'));\nconsole.log(regex.test('I have a dog'));\nconsole.log(regex.test('I have a bird'));\n```",
    category: 'javascript',
    subcategory: 'regex',
    difficulty: 'easy',
    options: [
      'true true true',
      'true true false',
      'false false false',
      'true false false',
    ],
    correctAnswer: 1,
    explanation: "**| = OR operator** - matches either pattern!\n\n**Think of | like a fork in the road** - you can take either path!\n\n**What happens:**\n```javascript\nconst regex = /cat|dog/;\n\nregex.test('I have a cat');  // true ‚úÖ (has 'cat'!)\nregex.test('I have a dog');  // true ‚úÖ (has 'dog'!)\nregex.test('I have a bird'); // false ‚ùå (no 'cat' or 'dog')\n```\n\n**OR patterns:**\n```javascript\n// Match cat OR dog:\n/cat|dog/.test('cat');   // true\n/cat|dog/.test('dog');   // true\n/cat|dog/.test('bird');  // false\n\n// Multiple alternatives:\n/red|green|blue/.test('red');    // true\n/red|green|blue/.test('green');  // true\n/red|green|blue/.test('yellow'); // false\n\n// Numbers:\n/1|2|3/.test('2');  // true\n/1|2|3/.test('4');  // false\n```\n\n**Order matters:**\n```javascript\n// Regex tries alternatives left to right:\n/cat|category/.test('category');\n// Matches 'cat' (first alternative)\n// Doesn't try 'category'!\n\n// Better: longer patterns first:\n/category|cat/.test('category');\n// Matches 'category' ‚úÖ\n```\n\n**Grouping with OR:**\n```javascript\n// Without grouping:\n/cat|dog food/.test('cat food');  // true (matches 'cat')\n/cat|dog food/.test('dog food');  // true (matches 'dog food')\n// Pattern is: 'cat' OR 'dog food'\n\n// With grouping:\n/(cat|dog) food/.test('cat food');  // true\n/(cat|dog) food/.test('dog food');  // true\n/(cat|dog) food/.test('bird food'); // false\n// Pattern is: ('cat' OR 'dog') + ' food'\n```\n\n**Practical examples:**\n```javascript\n// File extensions:\n/\\.(jpg|png|gif)$/.test('image.jpg');  // true\n/\\.(jpg|png|gif)$/.test('image.pdf');  // false\n\n// Yes or No:\n/^(yes|no)$/i.test('YES');  // true\n/^(yes|no)$/i.test('maybe'); // false\n```\n\n**Memory trick:** | = OR, matches either alternative!",
    tags: ['regex', 'alternation'],
  },

{
    id: 'js-234',
    question: "üìù What's the output?\n\n```javascript\nconst regex = /a{2,4}/;\nconsole.log(regex.test('a'));\nconsole.log(regex.test('aa'));\nconsole.log(regex.test('aaaaa'));\n```",
    category: 'javascript',
    subcategory: 'regex',
    difficulty: 'medium',
    options: [
      'false true true',
      'true true true',
      'false true false',
      'true false true',
    ],
    correctAnswer: 0,
    explanation: "**{2,4} = between 2 and 4 occurrences** - specific range!\n\n**What happens:**\n```javascript\nconst regex = /a{2,4}/;\n\nregex.test('a');     // false ‚ùå (only 1, need 2-4)\nregex.test('aa');    // true ‚úÖ (2 matches range)\nregex.test('aaaaa'); // true ‚úÖ (contains 'aaaa'!)\n```\n\n**Quantifier ranges:**\n```javascript\n// {n} = exactly n:\n/a{3}/.test('aa');    // false (only 2)\n/a{3}/.test('aaa');   // true (exactly 3)\n/a{3}/.test('aaaa');  // true (contains 'aaa')\n\n// {n,} = n or more:\n/a{2,}/.test('a');     // false (only 1)\n/a{2,}/.test('aa');    // true (2 or more)\n/a{2,}/.test('aaaaa'); // true (5 or more)\n\n// {n,m} = between n and m:\n/a{2,4}/.test('a');      // false (only 1)\n/a{2,4}/.test('aa');     // true (2)\n/a{2,4}/.test('aaa');    // true (3)\n/a{2,4}/.test('aaaa');   // true (4)\n/a{2,4}/.test('aaaaa');  // true (matches first 4)\n```\n\n**Why 'aaaaa' matches:**\n```javascript\n// /a{2,4}/ looks for 2-4 consecutive 'a's\n// 'aaaaa' contains 'aaaa' (4 a's) at the start\n\n'aaaaa'\n ‚Üë‚Üë‚Üë‚Üë\n ‚îî‚îÄ‚î¥‚îÄ‚î¥‚îÄ‚î¥‚îÄ Matches 4 a's! ‚úÖ\n```\n\n**Practical examples:**\n```javascript\n// Phone number (3 digits, dash, 4 digits):\n/\\d{3}-\\d{4}/.test('123-4567');  // true\n\n// ZIP code (5 or 9 digits):\n/^\\d{5}(-\\d{4})?$/.test('12345');      // true\n/^\\d{5}(-\\d{4})?$/.test('12345-6789'); // true\n\n// Password (8-20 characters):\n/^.{8,20}$/.test('password');  // true (8 chars)\n/^.{8,20}$/.test('pass');      // false (4 chars)\n```\n\n**Memory trick:** {n,m} = between n and m occurrences!",
    tags: ['regex', 'quantifiers'],
  },

{
    id: 'js-235',
    question: "üìù What's the difference between exec() and match()?\n\n```javascript\nconst text = 'cat bat';\nconst regex = /(\\w+)at/;\n\nconst result1 = regex.exec(text);\nconst result2 = text.match(regex);\n```",
    category: 'javascript',
    subcategory: 'regex',
    difficulty: 'hard',
    options: [
      'exec() and match() return identical results',
      'exec() is a regex method, match() is a string method',
      'exec() updates regex.lastIndex, match() does not',
      'Both B and C are correct',
    ],
    correctAnswer: 3,
    explanation: "**exec() = regex method with state, match() = string method** - both correct!\n\n**What happens:**\n```javascript\nconst text = 'cat bat';\nconst regex = /(\\w+)at/;\n\nconst result1 = regex.exec(text);\nconst result2 = text.match(regex);\n\n// Both return same structure:\n// ['cat', 'c', index: 0, input: 'cat bat', groups: undefined]\n// But called differently!\n```\n\n**Key differences:**\n```javascript\n// 1. Method location:\nregex.exec(text);  // Called on regex ‚úÖ\ntext.match(regex); // Called on string ‚úÖ\n\n// 2. State management with 'g':\nconst regex = /(\\w+)at/g;\n\n// exec() maintains lastIndex:\nregex.exec('cat bat');  // ['cat', 'c'] (first match)\nregex.lastIndex;        // 3 (updated!)\nregex.exec('cat bat');  // ['bat', 'b'] (next match)\nregex.lastIndex;        // 7 (updated again!)\n\n// match() returns all at once:\n'cat bat'.match(/(\\w+)at/g);  // ['cat', 'bat']\n// No state, no lastIndex\n```\n\n**Global regex behavior:**\n```javascript\nconst text = 'cat bat rat';\n\n// exec() with 'g' - iterate manually:\nconst regex = /\\wat/g;\nlet match;\nwhile ((match = regex.exec(text)) !== null) {\n  console.log(match[0]);  // 'cat', 'bat', 'rat'\n  console.log(regex.lastIndex);  // 3, 7, 11\n}\n\n// match() with 'g' - all at once:\ntext.match(/\\wat/g);  // ['cat', 'bat', 'rat']\n```\n\n**Without 'g' - nearly identical:**\n```javascript\nconst text = 'cat bat';\nconst regex = /(\\w+)at/;  // No 'g'\n\n// exec():\nregex.exec(text);\n// ['cat', 'c', index: 0, input: 'cat bat', groups: undefined]\n\n// match():\ntext.match(regex);\n// ['cat', 'c', index: 0, input: 'cat bat', groups: undefined]\n\n// Results are the same! ‚úÖ\n```\n\n**Memory trick:** exec = regex method + state, match = string method + simple!",
    tags: ['regex', 'methods'],
  },

{
    id: 'js-236',
    question: "üìù What does \\s match?\n\n```javascript\nconst regex = /\\s/;\nconsole.log(regex.test(' '));\nconsole.log(regex.test('\\n'));\nconsole.log(regex.test('\\t'));\nconsole.log(regex.test('a'));\n```",
    category: 'javascript',
    subcategory: 'regex',
    difficulty: 'easy',
    options: [
      'true false false false',
      'true true true false',
      'true true false false',
      'false false false false',
    ],
    correctAnswer: 1,
    explanation: "**\\s matches ALL whitespace** - space, newline, tab, etc!\n\n**What happens:**\n```javascript\nconst regex = /\\s/;\n\nregex.test(' ');   // true ‚úÖ (space)\nregex.test('\\n');  // true ‚úÖ (newline)\nregex.test('\\t');  // true ‚úÖ (tab)\nregex.test('a');   // false ‚ùå (not whitespace)\n```\n\n**Whitespace characters:**\n```javascript\n// \\s matches:\n' '   // Space\n'\\n'  // Newline\n'\\t'  // Tab\n'\\r'  // Carriage return\n'\\f'  // Form feed\n'\\v'  // Vertical tab\n\n// \\s does NOT match:\n'a'   // Letters\n'1'   // Digits\n'_'   // Underscore\n```\n\n**Practical examples:**\n```javascript\n// Trim spaces:\n'  hello  '.replace(/^\\s+|\\s+$/g, '');  // 'hello'\n\n// Split on whitespace:\n'cat  dog\\ntab'.split(/\\s+/);  // ['cat', 'dog', 'tab']\n\n// Check for spaces:\n/\\s/.test('hello world');  // true (has space)\n/\\s/.test('helloworld');   // false (no space)\n\n// Remove all whitespace:\n'a b c\\nd'.replace(/\\s/g, '');  // 'abcd'\n```\n\n**\\s vs \\S (inverse):**\n```javascript\n// \\s = whitespace:\n/\\s/.test(' ');   // true\n/\\s/.test('a');   // false\n\n// \\S = NON-whitespace:\n/\\S/.test(' ');   // false\n/\\S/.test('a');   // true\n/\\S/.test('!');   // true\n```\n\n**Memory trick:** \\s = space/whitespace, includes space/newline/tab!",
    tags: ['regex', 'character-classes'],
  },

{
    id: 'js-237',
    question: "üìù What's the output?\n\n```javascript\nconst regex = /^\\d{3}-\\d{4}$/;\nconsole.log(regex.test('123-4567'));\nconsole.log(regex.test('12-4567'));\nconsole.log(regex.test('123-456'));\n```",
    category: 'javascript',
    subcategory: 'regex',
    difficulty: 'medium',
    options: [
      'true true true',
      'true false false',
      'false false false',
      'true true false',
    ],
    correctAnswer: 1,
    explanation: "**^\\d{3}-\\d{4}$ = exact format: 3 digits-4 digits** - anchors enforce precision!\n\n**What happens:**\n```javascript\nconst regex = /^\\d{3}-\\d{4}$/;\n\n// Pattern breakdown:\n// ^       = start of string\n// \\d{3}   = exactly 3 digits\n// -       = literal dash\n// \\d{4}   = exactly 4 digits\n// $       = end of string\n\nregex.test('123-4567');  // true ‚úÖ (exact match!)\nregex.test('12-4567');   // false ‚ùå (only 2 digits)\nregex.test('123-456');   // false ‚ùå (only 3 digits)\n```\n\n**Why others fail:**\n```javascript\n// '12-4567' - needs 3 digits before dash:\n'12-4567'\n ‚Üë‚Üë\n Only 2 digits! Need 3 ‚ùå\n\n// '123-456' - needs 4 digits after dash:\n'123-456'\n    ‚Üë‚Üë‚Üë\n    Only 3 digits! Need 4 ‚ùå\n\n// '123-4567' - perfect match:\n'123-4567'\n ‚Üë‚Üë‚Üë ‚Üë‚Üë‚Üë‚Üë\n  3    4   ‚úÖ\n```\n\n**Without anchors:**\n```javascript\n// Without ^ and $:\n/\\d{3}-\\d{4}/.test('abc123-4567xyz');  // true\n// Matches '123-4567' inside longer string!\n\n// With anchors:\n/^\\d{3}-\\d{4}$/.test('abc123-4567xyz');  // false\n// Requires EXACT match, no extra characters\n```\n\n**Similar patterns:**\n```javascript\n// US phone: (123) 456-7890\n/^\\(\\d{3}\\) \\d{3}-\\d{4}$/\n\n// Date: 2024-01-15\n/^\\d{4}-\\d{2}-\\d{2}$/\n\n// Time: 14:30:00\n/^\\d{2}:\\d{2}:\\d{2}$/\n\n// ZIP: 12345 or 12345-6789\n/^\\d{5}(-\\d{4})?$/\n```\n\n**Memory trick:** Anchors + exact counts = precise format validation!",
    tags: ['regex', 'patterns', 'anchors'],
  },

{
    id: 'js-238',
    question: "üìù What's the output?\n\n```javascript\nconst regex = /hello/i;\nconsole.log(regex.test('Hello'));\nconsole.log(regex.test('HELLO'));\nconsole.log(regex.test('hello'));\n```",
    category: 'javascript',
    subcategory: 'regex',
    difficulty: 'easy',
    options: [
      'false false true',
      'true true true',
      'true false true',
      'false true true',
    ],
    correctAnswer: 1,
    explanation: "**'i' flag = case-insensitive** - matches ANY case variation!\n\n**What happens:**\n```javascript\nconst regex = /hello/i;  // 'i' = ignore case\n\nregex.test('Hello');  // true ‚úÖ\nregex.test('HELLO');  // true ‚úÖ\nregex.test('hello');  // true ‚úÖ\n// All variations match!\n```\n\n**With vs without 'i':**\n```javascript\n// Without 'i' - case-sensitive:\n/hello/.test('Hello');  // false ‚ùå (capital H!)\n/hello/.test('HELLO');  // false ‚ùå (all caps!)\n/hello/.test('hello');  // true ‚úÖ\n\n// With 'i' - case-insensitive:\n/hello/i.test('Hello');  // true ‚úÖ\n/hello/i.test('HELLO');  // true ‚úÖ\n/hello/i.test('hello');  // true ‚úÖ\n/hello/i.test('HeLLo');  // true ‚úÖ\n```\n\n**Common use cases:**\n```javascript\n// Search regardless of case:\n/search/i.test('SEARCH');  // true\n/search/i.test('Search');  // true\n\n// Email validation:\n/^[a-z]+@[a-z]+\\.[a-z]+$/i.test('USER@SITE.COM');  // true\n\n// Yes/No input:\n/^yes$/i.test('YES');    // true\n/^yes$/i.test('Yes');    // true\n/^yes$/i.test('yes');    // true\n\n// Word search in text:\n/\\bcat\\b/i.test('I love my CAT');  // true\n```\n\n**Multiple flags:**\n```javascript\n// Combine 'i' with other flags:\n/hello/gi;   // global + case-insensitive\n/hello/im;   // case-insensitive + multiline\n/hello/gim;  // all three!\n\n'Hello HELLO hello'.match(/hello/gi);\n// ['Hello', 'HELLO', 'hello'] ‚úÖ\n```\n\n**Memory trick:** 'i' flag = ignore case, matches all variations!",
    tags: ['regex', 'flags'],
  },
];
