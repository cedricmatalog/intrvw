import { QuizQuestion } from '../../types/quiz';

export const map_setQuizzes: QuizQuestion[] = [
{
    id: 'js-081',
    question: "ğŸ“ What's the output?\n\n```javascript\nconst set = new Set([1, 1, 2, 3, 4]);\n\nconsole.log(set);\n```",
    category: 'javascript',
    subcategory: 'map-set',
    difficulty: 'medium',
    options: [
          "[1, 1, 2, 3, 4]",
          "[1, 2, 3, 4]",
          "{1, 1, 2, 3, 4}",
          "{1, 2, 3, 4}"
    ],
    correctAnswer: 3,
    explanation: "**Set automatically removes duplicates** - it's a collection of UNIQUE values only!\n\n**Think of Set like a VIP list** - you can't get on the list twice, even if you try!\n\n**What happens:**\n```javascript\nconst set = new Set([1, 1, 2, 3, 4]);\n//                   ^  ^\n//                   Second 1 is ignored!\n\nconsole.log(set);  // Set(4) { 1, 2, 3, 4 } âœ…\n```\n\n**Step-by-step:**\n```javascript\n// Array: [1, 1, 2, 3, 4]\n// Set constructor iterates and adds each value:\n\nset.add(1);  // Set { 1 }\nset.add(1);  // Set { 1 } â† Duplicate ignored!\nset.add(2);  // Set { 1, 2 }\nset.add(3);  // Set { 1, 2, 3 }\nset.add(4);  // Set { 1, 2, 3, 4 }\n```\n\n**Set notation:**\n```javascript\n// Arrays use square brackets:\n[1, 2, 3]  // Array\n\n// Sets use curly braces (like objects, but no keys):\n{1, 2, 3}  // Set notation\nSet(3) {1, 2, 3}  // Full Set output\n```\n\n**Common use case - remove duplicates:**\n```javascript\nconst arr = [1, 1, 2, 2, 3, 3];\nconst unique = [...new Set(arr)];  // [1, 2, 3] âœ…\n```\n\n**Memory trick:** Set = automatically unique, displayed with {} not []!",
    tags: ["javascript","quiz", "set", "collections"],
  },

{
    id: 'js-239',
    question: "ğŸ“ What's the output?\n\n```javascript\nconst map = new Map();\nmap.set('key', 'value');\nmap.set('key', 'new value');\n\nconsole.log(map.size);\n```",
    category: 'javascript',
    subcategory: 'map-set',
    difficulty: 'easy',
    options: [
      '0',
      '1',
      '2',
      'undefined',
    ],
    correctAnswer: 1,
    explanation: "**Map keys are unique** - setting the same key twice overwrites the previous value!\n\n**Think of Map like a parking spot** - if you park again in the same spot, your old car is replaced, not duplicated!\n\n**What happens:**\n```javascript\nconst map = new Map();\n\nmap.set('key', 'value');      // Map { 'key' => 'value' }\nmap.set('key', 'new value');  // Map { 'key' => 'new value' }\n//       ^^^^                    ^^^^\n//       Same key!               Overwrites!\n\nconsole.log(map.size);  // 1 âœ…\n// Only ONE key 'key', with latest value 'new value'\n```\n\n**Step-by-step:**\n```javascript\n// After first set:\nmap.size;        // 1\nmap.get('key');  // 'value'\n\n// After second set:\nmap.size;        // Still 1 (same key!)\nmap.get('key');  // 'new value' (overwritten)\n```\n\n**Compare with adding different keys:**\n```javascript\nconst map = new Map();\nmap.set('key1', 'value1');  // Map { 'key1' => 'value1' }\nmap.set('key2', 'value2');  // Map { 'key1' => 'value1', 'key2' => 'value2' }\n\nmap.size;  // 2 âœ… Different keys!\n```\n\n**Memory trick:** Same key = update, different key = add!",
    tags: ['map', 'collections'],
  },

{
    id: 'js-240',
    question: "ğŸ“ What's the output?\n\n```javascript\nconst set = new Set([1, 2, 2, 3, 3, 3]);\nconsole.log(set.size);\nconsole.log([...set]);\n```",
    category: 'javascript',
    subcategory: 'map-set',
    difficulty: 'easy',
    options: [
      '6 and [1, 2, 2, 3, 3, 3]',
      '3 and [1, 2, 3]',
      '6 and [1, 2, 3]',
      '3 and [1, 2, 2, 3, 3, 3]',
    ],
    correctAnswer: 1,
    explanation: "**Set stores only unique values** - duplicates vanish automatically!\n\n**Think of Set like a stamp collection** - you don't keep duplicate stamps, just one of each!\n\n**What happens:**\n```javascript\nconst set = new Set([1, 2, 2, 3, 3, 3]);\n//                   ^  ^  ^  ^  ^  ^\n//                   Kept, ignored duplicates\n\n// Set keeps: {1, 2, 3}\nset.size;  // 3 âœ…\n\n[...set];  // [1, 2, 3] âœ…\n// Spread converts Set back to array\n```\n\n**Deduplication process:**\n```javascript\nconst arr = [1, 2, 2, 3, 3, 3];\n\n// Set constructor:\nset.add(1);  // Set {1}\nset.add(2);  // Set {1, 2}\nset.add(2);  // Set {1, 2} â† Ignored!\nset.add(3);  // Set {1, 2, 3}\nset.add(3);  // Set {1, 2, 3} â† Ignored!\nset.add(3);  // Set {1, 2, 3} â† Ignored!\n\n// Final: Set {1, 2, 3} with size 3\n```\n\n**Common pattern:**\n```javascript\n// Remove duplicates from array:\nconst arr = [1, 1, 2, 2, 3, 3];\nconst unique = [...new Set(arr)];  // [1, 2, 3] âœ…\n```\n\n**Memory trick:** Set = automatic duplicate removal, size = unique count!",
    tags: ['set', 'collections', 'uniqueness'],
  },

{
    id: 'js-241',
    question: "ğŸ“ What's the output?\n\n```javascript\nconst map = new Map();\nconst obj = { name: 'John' };\n\nmap.set(obj, 'value1');\nmap.set({ name: 'John' }, 'value2');\n\nconsole.log(map.size);\n```",
    category: 'javascript',
    subcategory: 'map-set',
    difficulty: 'medium',
    options: [
      '1',
      '2',
      '0',
      'Error',
    ],
    correctAnswer: 1,
    explanation: "**Map uses reference equality for object keys** - same content doesn't mean same object!\n\n**Think of Map keys like house addresses** - two identical houses at different addresses are different properties!\n\n**What happens:**\n```javascript\nconst obj = { name: 'John' };  // Object at memory address A\n\nmap.set(obj, 'value1');\n// Key: reference to address A\n\nmap.set({ name: 'John' }, 'value2');\n//       ^^^^^^^^^^^^^^^^\n//       NEW object at address B!\n// Key: reference to address B\n\nmap.size;  // 2 âœ… Two different references!\n```\n\n**Visual representation:**\n```javascript\nMemory:\n  Address 0x001: { name: 'John' }  â† obj points here\n  Address 0x002: { name: 'John' }  â† literal points here\n\nMap:\n  0x001 => 'value1'  â† First key\n  0x002 => 'value2'  â† Second key (different!)\n```\n\n**Compare with same reference:**\n```javascript\nconst map = new Map();\nconst obj = { name: 'John' };\n\nmap.set(obj, 'value1');\nmap.set(obj, 'value2');  // SAME reference!\n//      ^^^\n\nmap.size;  // 1 âœ… Same key, overwrites!\nmap.get(obj);  // 'value2'\n```\n\n**Why this matters:**\n```javascript\n// Can use objects as keys:\nconst userPrefs = new Map();\nconst user1 = { id: 1 };\nconst user2 = { id: 1 };  // Same content, different object\n\nuserPrefs.set(user1, { theme: 'dark' });\nuserPrefs.set(user2, { theme: 'light' });\n\nuserPrefs.size;  // 2 (different objects)\n```\n\n**Memory trick:** Map compares object references, not content!",
    tags: ['map', 'references', 'collections'],
  },

{
    id: 'js-242',
    question: "ğŸ“ What's the main difference between Map and Object?\n\n```javascript\nconst obj = {};\nconst map = new Map();\n\nobj[1] = 'one';\nmap.set(1, 'one');\n\nconsole.log(typeof Object.keys(obj)[0]);\nconsole.log(typeof [...map.keys()][0]);\n```",
    category: 'javascript',
    subcategory: 'map-set',
    difficulty: 'medium',
    options: [
      'string and string',
      'string and number',
      'number and number',
      'number and string',
    ],
    correctAnswer: 1,
    explanation: "**Object keys are ALWAYS strings** (or Symbols), but Map preserves key types!\n\n**Think of Objects like filing cabinets** - all folder labels are strings. Maps are like databases - they preserve the exact type of your key!\n\n**What happens:**\n```javascript\nconst obj = {};\nobj[1] = 'one';\n//  ^\n//  Converted to string '1'!\n\nObject.keys(obj)[0];  // '1' (string) âœ…\ntypeof Object.keys(obj)[0];  // 'string'\n\n// Proof:\nobj[1] === obj['1'];  // true (same key!)\n```\n\n**Map preserves types:**\n```javascript\nconst map = new Map();\nmap.set(1, 'one');\n//      ^\n//      Stays as number!\n\n[...map.keys()][0];  // 1 (number) âœ…\ntypeof [...map.keys()][0];  // 'number'\n\n// Proof:\nmap.get(1) !== map.get('1');  // Different keys!\n```\n\n**Object key coercion:**\n```javascript\nconst obj = {};\nobj[1] = 'a';\nobj['1'] = 'b';\nobj[true] = 'c';\nobj['true'] = 'd';\n\nObject.keys(obj);  // ['1', 'true'] âœ…\n// All converted to strings!\n\nobj[1];      // 'd' (overwrote!)\nobj[true];   // 'd' (same as obj['true'])\n```\n\n**Map type preservation:**\n```javascript\nconst map = new Map();\nmap.set(1, 'a');\nmap.set('1', 'b');\nmap.set(true, 'c');\nmap.set('true', 'd');\n\nmap.size;  // 4 âœ… All different keys!\n\nmap.get(1);      // 'a'\nmap.get('1');    // 'b'\nmap.get(true);   // 'c'\nmap.get('true'); // 'd'\n```\n\n**Memory trick:** Objects stringify keys, Maps keep original types!",
    tags: ['map', 'objects', 'types'],
  },

{
    id: 'js-243',
    question: "ğŸ“ What's the output?\n\n```javascript\nconst set = new Set([1, 2, 3]);\nset.add(4);\nset.delete(2);\nset.add(1);\n\nconsole.log(set.size);\n```",
    category: 'javascript',
    subcategory: 'map-set',
    difficulty: 'easy',
    options: [
      '3',
      '4',
      '5',
      '2',
    ],
    correctAnswer: 0,
    explanation: "**Set operations: add inserts unique values, delete removes them, duplicate adds are ignored!**\n\n**Think of Set like a guest list** - you can add new guests, remove guests, but adding someone already on the list does nothing!\n\n**Step-by-step:**\n```javascript\nconst set = new Set([1, 2, 3]);\n// Initial: Set {1, 2, 3}, size = 3\n\nset.add(4);\n// Set {1, 2, 3, 4}, size = 4\n\nset.delete(2);\n// Set {1, 3, 4}, size = 3\n\nset.add(1);\n// Set {1, 3, 4}, size = 3\n// 1 already exists, ignored!\n\nset.size;  // 3 âœ…\n```\n\n**Visual timeline:**\n```javascript\nStart:       {1, 2, 3}       size: 3\nadd(4):      {1, 2, 3, 4}    size: 4\ndelete(2):   {1, 3, 4}       size: 3\nadd(1):      {1, 3, 4}       size: 3 (no change)\n```\n\n**Set.add() behavior:**\n```javascript\nconst set = new Set();\n\nset.add(1);  // Set {1}, returns Set {1}\nset.add(1);  // Set {1}, returns Set {1} (no change)\nset.add(2);  // Set {1, 2}, returns Set {1, 2}\n```\n\n**Set.delete() behavior:**\n```javascript\nconst set = new Set([1, 2, 3]);\n\nset.delete(2);  // true (was present, now removed)\nset.delete(2);  // false (wasn't present)\nset.delete(99); // false (wasn't present)\n```\n\n**Memory trick:** add(existing) = no-op, delete(missing) = false!",
    tags: ['set', 'methods'],
  },

{
    id: 'js-244',
    question: "ğŸ“ What's the output?\n\n```javascript\nconst map = new Map([\n  ['a', 1],\n  ['b', 2]\n]);\n\nconsole.log(map.get('a'));\nconsole.log(map.get('c'));\n```",
    category: 'javascript',
    subcategory: 'map-set',
    difficulty: 'easy',
    options: [
      '1 and null',
      '1 and undefined',
      'undefined and undefined',
      '1 and 0',
    ],
    correctAnswer: 1,
    explanation: "**Map.get() returns the value for existing keys, undefined for missing keys!**\n\n**Think of Map like a dictionary** - you can look up words (keys), but if the word isn't there, you get nothing (undefined), not an error!\n\n**What happens:**\n```javascript\nconst map = new Map([\n  ['a', 1],\n  ['b', 2]\n]);\n\nmap.get('a');  // 1 âœ… Key exists\nmap.get('c');  // undefined âœ… Key doesn't exist\n```\n\n**Map constructor syntax:**\n```javascript\n// Takes array of [key, value] pairs:\nnew Map([\n  ['key1', 'value1'],\n  ['key2', 'value2']\n]);\n\n// Equivalent to:\nconst map = new Map();\nmap.set('key1', 'value1');\nmap.set('key2', 'value2');\n```\n\n**Why undefined, not null:**\n```javascript\nconst map = new Map();\n\nmap.get('missing');  // undefined (not in map)\n\n// But you CAN store null as a value:\nmap.set('key', null);\nmap.get('key');  // null (explicit value)\n\n// Check if key exists:\nmap.has('key');     // true\nmap.has('missing'); // false\n```\n\n**Memory trick:** get(missing) = undefined, has(missing) = false!",
    tags: ['map', 'methods'],
  },

{
    id: 'js-245',
    question: "ğŸ“ Which is more efficient for checking if a value exists in a large collection?\n\n```javascript\nconst array = [1, 2, 3, /* ... 10000 items */];\nconst set = new Set([1, 2, 3, /* ... 10000 items */]);\n\narray.includes(9999);\nset.has(9999);\n```",
    category: 'javascript',
    subcategory: 'map-set',
    difficulty: 'medium',
    options: [
      'array.includes() is faster',
      'set.has() is faster',
      'Same performance',
      'Depends on the values',
    ],
    correctAnswer: 1,
    explanation: "**Set.has() is O(1) constant time, array.includes() is O(n) linear time** - massive difference for large collections!\n\n**Think of it like finding a house** - Set is GPS (instant), array is driving street-by-street until you find it!\n\n**Performance comparison:**\n```javascript\n// Array.includes() - O(n) Linear Search\nconst array = [1, 2, 3, ..., 10000];\narray.includes(9999);\n// Must check: 1? No. 2? No. 3? No... 9999? Yes!\n// Worst case: checks all 10,000 items\n\n// Set.has() - O(1) Hash Lookup\nconst set = new Set([1, 2, 3, ..., 10000]);\nset.has(9999);\n// Hash 9999 â†’ Check that bucket â†’ Found!\n// Always ~1 operation, regardless of size\n```\n\n**Speed difference:**\n```javascript\n// Small collection (10 items): Similar speed\narray.includes(x);  // ~10 operations\nset.has(x);         // ~1 operation\n\n// Large collection (10,000 items): HUGE difference\narray.includes(x);  // ~10,000 operations (worst case)\nset.has(x);         // ~1 operation\n\n// 10,000Ã— faster! âœ…\n```\n\n**When to use each:**\n```javascript\n// Use Set for:\nâœ… Frequent existence checks\nâœ… Large collections\nâœ… Unique values\nâœ… Fast add/delete\n\n// Use Array for:\nâœ… Ordered data\nâœ… Indexed access (arr[0])\nâœ… Duplicates allowed\nâœ… Array methods (map, filter, reduce)\n```\n\n**Real-world example:**\n```javascript\n// âŒ Slow - O(nÂ²)\nconst arr = [/* 1000 items */];\nfor (const item of items) {\n  if (arr.includes(item)) {  // Checks all 1000 each time!\n    // ...\n  }\n}\n\n// âœ… Fast - O(n)\nconst set = new Set([/* 1000 items */]);\nfor (const item of items) {\n  if (set.has(item)) {  // Instant lookup!\n    // ...\n  }\n}\n```\n\n**Memory trick:** Set = hash table (instant), Array = sequential scan (slow)!",
    tags: ['set', 'performance', 'arrays'],
  },

{
    id: 'js-246',
    question: "ğŸ“ What's the output?\n\n```javascript\nconst map = new Map();\nmap.set(NaN, 'value');\n\nconsole.log(map.get(NaN));\nconsole.log(NaN === NaN);\n```",
    category: 'javascript',
    subcategory: 'map-set',
    difficulty: 'hard',
    options: [
      'undefined and false',
      'value and false',
      'undefined and true',
      'value and true',
    ],
    correctAnswer: 1,
    explanation: "**Map treats NaN as equal to itself** - special case that fixes JavaScript's broken NaN === NaN!\n\n**Think of Map like a smart assistant** - it knows NaN is special and treats all NaN values as the same key, unlike regular === comparison!\n\n**What happens:**\n```javascript\nconst map = new Map();\nmap.set(NaN, 'value');\n\n// Map treats NaN specially:\nmap.get(NaN);  // 'value' âœ…\n// Even though...\nNaN === NaN;   // false âœ… (JavaScript quirk)\n```\n\n**Why this is special:**\n```javascript\n// Regular JavaScript - NaN is never equal to itself:\nNaN === NaN;  // false âŒ\nNaN == NaN;   // false âŒ\n\n// But Map uses SameValueZero algorithm:\nconst map = new Map();\nmap.set(NaN, 'first');\nmap.set(NaN, 'second');  // Overwrites!\n\nmap.size;  // 1 (treated as same key)\nmap.get(NaN);  // 'second'\n```\n\n**Visual representation:**\n```javascript\n// What you'd expect (but doesn't happen with ===):\nconst obj = {};\nobj[NaN] = 'value';\nobj[NaN];  // 'value' (but uses string 'NaN' as key!)\n\n// What actually happens:\ntypeof Object.keys(obj)[0];  // 'string'\nObject.keys(obj)[0];         // 'NaN' (stringified!)\n\n// Map preserves NaN properly:\nconst map = new Map([[NaN, 'value']]);\n[...map.keys()][0] === NaN;  // false (because NaN !== NaN)\nNumber.isNaN([...map.keys()][0]);  // true âœ…\n```\n\n**Same with Set:**\n```javascript\nconst set = new Set();\nset.add(NaN);\nset.add(NaN);\nset.add(NaN);\n\nset.size;  // 1 âœ… All NaN treated as duplicate!\nset.has(NaN);  // true âœ…\n```\n\n**Memory trick:** Map/Set use SameValueZero, not ===, so NaN works correctly!",
    tags: ['map', 'NaN', 'edge-cases'],
  },

{
    id: 'js-247',
    question: "ğŸ“ How do you iterate over a Map?\n\n```javascript\nconst map = new Map([['a', 1], ['b', 2]]);\n\nfor (const [key, value] of map) {\n  console.log(key, value);\n}\n```",
    category: 'javascript',
    subcategory: 'map-set',
    difficulty: 'medium',
    options: [
      'Logs: a 1, b 2',
      'Error: Map is not iterable',
      'Logs: [\'a\', 1], [\'b\', 2]',
      'Logs: undefined undefined',
    ],
    correctAnswer: 0,
    explanation: "**Map is iterable** - for...of loops through [key, value] pairs that you can destructure!\n\n**Think of Map iteration like opening envelopes** - each envelope contains a key-value pair, and destructuring opens it!\n\n**What happens:**\n```javascript\nconst map = new Map([['a', 1], ['b', 2]]);\n\nfor (const [key, value] of map) {\n  //       ^^^^^^^^^^^^^\n  //       Destructuring the [key, value] pair\n  console.log(key, value);\n}\n\n// Output:\n// a 1\n// b 2\n```\n\n**How Map iteration works:**\n```javascript\n// Map implements Symbol.iterator:\nconst map = new Map([['a', 1], ['b', 2]]);\nconst iter = map[Symbol.iterator]();\n\niter.next();  // { value: ['a', 1], done: false }\niter.next();  // { value: ['b', 2], done: false }\niter.next();  // { done: true }\n```\n\n**Different iteration methods:**\n```javascript\nconst map = new Map([['a', 1], ['b', 2]]);\n\n// 1. Iterate entries (default):\nfor (const [key, value] of map) {\n  console.log(key, value);  // a 1, b 2\n}\n\n// 2. Iterate entries explicitly:\nfor (const [key, value] of map.entries()) {\n  console.log(key, value);  // a 1, b 2\n}\n\n// 3. Iterate keys only:\nfor (const key of map.keys()) {\n  console.log(key);  // a, b\n}\n\n// 4. Iterate values only:\nfor (const value of map.values()) {\n  console.log(value);  // 1, 2\n}\n\n// 5. forEach method:\nmap.forEach((value, key) => {\n  console.log(key, value);  // a 1, b 2\n});\n```\n\n**Without destructuring:**\n```javascript\nfor (const entry of map) {\n  console.log(entry);  // ['a', 1], then ['b', 2]\n}\n```\n\n**Memory trick:** Map iterates as [key, value] pairs, perfect for destructuring!",
    tags: ['map', 'iteration', 'destructuring'],
  },

{
    id: 'js-248',
    question: "ğŸ“ What's the output?\n\n```javascript\nconst set1 = new Set([1, 2, 3]);\nconst set2 = new Set([1, 2, 3]);\n\nconsole.log(set1 === set2);\nconsole.log([...set1].toString() === [...set2].toString());\n```",
    category: 'javascript',
    subcategory: 'map-set',
    difficulty: 'medium',
    options: [
      'true and true',
      'false and true',
      'true and false',
      'false and false',
    ],
    correctAnswer: 1,
    explanation: "**Sets are objects** - === compares references, not contents!\n\n**Think of Sets like twin houses** - identical inside, but different addresses, so !== by reference!\n\n**What happens:**\n```javascript\nconst set1 = new Set([1, 2, 3]);  // Object at address A\nconst set2 = new Set([1, 2, 3]);  // Object at address B\n\n// Compare references:\nset1 === set2;  // false âœ… (different objects)\n\n// Compare contents:\n[...set1].toString();  // '1,2,3'\n[...set2].toString();  // '1,2,3'\n'1,2,3' === '1,2,3';   // true âœ… (same string)\n```\n\n**Visual representation:**\n```javascript\nMemory:\n  Address 0x001: Set {1, 2, 3}  â† set1\n  Address 0x002: Set {1, 2, 3}  â† set2\n\nset1 === set2  â†’  0x001 === 0x002  â†’  false âœ…\n```\n\n**Same reference comparison:**\n```javascript\nconst set1 = new Set([1, 2, 3]);\nconst set2 = set1;  // Same reference!\n\nset1 === set2;  // true âœ…\nset2.add(4);\nset1.has(4);    // true (same Set object)\n```\n\n**Comparing Set contents:**\n```javascript\n// Method 1: Convert to arrays and compare strings\nconst equal = [...set1].toString() === [...set2].toString();\n\n// Method 2: Check size and every element\nfunction setsEqual(a, b) {\n  if (a.size !== b.size) return false;\n  for (const item of a) {\n    if (!b.has(item)) return false;\n  }\n  return true;\n}\n\nsetsEqual(set1, set2);  // true âœ…\n```\n\n**Memory trick:** === compares addresses, not contents!",
    tags: ['set', 'references', 'comparison'],
  },

{
    id: 'js-249',
    question: "ğŸ“ What's the output?\n\n```javascript\nconst map = new Map();\nmap.set('key', 'value');\n\nconsole.log(map.has('key'));\nmap.clear();\nconsole.log(map.has('key'));\n```",
    category: 'javascript',
    subcategory: 'map-set',
    difficulty: 'easy',
    options: [
      'true and true',
      'true and false',
      'false and false',
      'false and true',
    ],
    correctAnswer: 1,
    explanation: "**Map.clear() removes ALL entries** - map becomes empty!\n\n**Think of clear() like erasing a whiteboard** - everything gone in one swipe!\n\n**What happens:**\n```javascript\nconst map = new Map();\nmap.set('key', 'value');\n\n// Before clear:\nmap.has('key');  // true âœ… (key exists)\nmap.size;        // 1\n\n// After clear:\nmap.clear();     // Removes everything\nmap.has('key');  // false âœ… (key gone)\nmap.size;        // 0\n```\n\n**Clear vs Delete:**\n```javascript\nconst map = new Map([['a', 1], ['b', 2], ['c', 3]]);\n\n// delete() - removes one entry:\nmap.delete('a');\nmap.size;  // 2 (b and c remain)\n\n// clear() - removes ALL entries:\nmap.clear();\nmap.size;  // 0 (everything gone)\n```\n\n**Same with Set:**\n```javascript\nconst set = new Set([1, 2, 3, 4, 5]);\nset.has(1);  // true\n\nset.clear();\nset.has(1);  // false\nset.size;    // 0\n```\n\n**Memory trick:** clear() = reset to empty, delete(key) = remove one!",
    tags: ['map', 'methods'],
  },

{
    id: 'js-250',
    question: "ğŸ“ What's the output?\n\n```javascript\nconst arr = [1, 2, 2, 3, 3, 3, 4, 4, 4, 4];\nconst unique = [...new Set(arr)];\n\nconsole.log(unique);\n```",
    category: 'javascript',
    subcategory: 'map-set',
    difficulty: 'easy',
    options: [
      '[1, 2, 3, 4]',
      '[1, 2, 2, 3, 3, 3, 4, 4, 4, 4]',
      'Set {1, 2, 3, 4}',
      'Error',
    ],
    correctAnswer: 0,
    explanation: "**Classic deduplication pattern** - Set removes duplicates, spread converts back to array!\n\n**Think of this like a two-step filter** - Set filters out duplicates, spread pours it back into an array!\n\n**What happens:**\n```javascript\nconst arr = [1, 2, 2, 3, 3, 3, 4, 4, 4, 4];\n\n// Step 1: Create Set (auto-deduplicates)\nnew Set(arr);  // Set {1, 2, 3, 4}\n\n// Step 2: Spread Set back to array\n[...new Set(arr)];  // [1, 2, 3, 4] âœ…\n```\n\n**Step-by-step breakdown:**\n```javascript\nconst arr = [1, 2, 2, 3, 3, 3, 4, 4, 4, 4];\n\n// Create Set:\nconst set = new Set(arr);\n// set.add(1)  â†’ Set {1}\n// set.add(2)  â†’ Set {1, 2}\n// set.add(2)  â†’ Set {1, 2} (ignored)\n// set.add(3)  â†’ Set {1, 2, 3}\n// set.add(3)  â†’ Set {1, 2, 3} (ignored)\n// ... etc\n// Final: Set {1, 2, 3, 4}\n\n// Spread operator:\nconst unique = [...set];\n// Takes each value from Set and puts in array\n// Result: [1, 2, 3, 4] âœ…\n```\n\n**This pattern everywhere:**\n```javascript\n// Remove duplicate strings:\nconst names = ['Alice', 'Bob', 'Alice', 'Charlie', 'Bob'];\nconst unique = [...new Set(names)];\n// ['Alice', 'Bob', 'Charlie']\n\n// Remove duplicate objects (by reference):\nconst obj1 = { id: 1 };\nconst obj2 = { id: 2 };\nconst arr = [obj1, obj2, obj1, obj2];\nconst unique = [...new Set(arr)];\n// [obj1, obj2] (2 unique references)\n```\n\n**Alternative: Array.from():**\n```javascript\nconst unique = Array.from(new Set(arr));\n// Same result: [1, 2, 3, 4]\n```\n\n**Memory trick:** [...new Set(arr)] = instant deduplication!",
    tags: ['set', 'arrays', 'patterns'],
  },
];
