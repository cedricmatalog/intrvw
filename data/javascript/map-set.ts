import { QuizQuestion } from '../../types/quiz';

export const map_setQuizzes: QuizQuestion[] = [
{
    id: 'js-239',
    question: "üìù What's the output?\n\n```javascript\nconst map = new Map();\nmap.set('key', 'value');\nmap.set('key', 'new value');\n\nconsole.log(map.size);\n```",
    category: 'javascript',
    subcategory: 'map-set',
    difficulty: 'easy',
    options: [
      '0',
      '1',
      '2',
      'undefined',
    ],
    correctAnswer: 1,
    explanation: "Map keys are unique. Setting the same key twice overwrites the previous value. The Map has only one key 'key' with value 'new value', so size is 1.",
    tags: ['map', 'collections'],
  },

{
    id: 'js-240',
    question: "üìù What's the output?\n\n```javascript\nconst set = new Set([1, 2, 2, 3, 3, 3]);\nconsole.log(set.size);\nconsole.log([...set]);\n```",
    category: 'javascript',
    subcategory: 'map-set',
    difficulty: 'easy',
    options: [
      '6 and [1, 2, 2, 3, 3, 3]',
      '3 and [1, 2, 3]',
      '6 and [1, 2, 3]',
      '3 and [1, 2, 2, 3, 3, 3]',
    ],
    correctAnswer: 1,
    explanation: "Set stores only unique values. Duplicates are automatically removed. The array [1, 2, 2, 3, 3, 3] becomes Set {1, 2, 3} with size 3. Spreading gives [1, 2, 3].",
    tags: ['set', 'collections', 'uniqueness'],
  },

{
    id: 'js-241',
    question: "üìù What's the output?\n\n```javascript\nconst map = new Map();\nconst obj = { name: 'John' };\n\nmap.set(obj, 'value1');\nmap.set({ name: 'John' }, 'value2');\n\nconsole.log(map.size);\n```",
    category: 'javascript',
    subcategory: 'map-set',
    difficulty: 'medium',
    options: [
      '1',
      '2',
      '0',
      'Error',
    ],
    correctAnswer: 1,
    explanation: "Map uses reference equality for object keys. Even though both objects have {name: 'John'}, they are different object references. Map treats them as two separate keys, so size is 2.",
    tags: ['map', 'references', 'collections'],
  },

{
    id: 'js-242',
    question: "üìù What's the main difference between Map and Object?\n\n```javascript\nconst obj = {};\nconst map = new Map();\n\nobj[1] = 'one';\nmap.set(1, 'one');\n\nconsole.log(typeof Object.keys(obj)[0]);\nconsole.log(typeof [...map.keys()][0]);\n```",
    category: 'javascript',
    subcategory: 'map-set',
    difficulty: 'medium',
    options: [
      'string and string',
      'string and number',
      'number and number',
      'number and string',
    ],
    correctAnswer: 1,
    explanation: "Object keys are always converted to strings. obj[1] becomes obj['1']. Map preserves key types - map.set(1, 'one') keeps the number key. First is 'string', second is 'number'.",
    tags: ['map', 'objects', 'types'],
  },

{
    id: 'js-243',
    question: "üìù What's the output?\n\n```javascript\nconst set = new Set([1, 2, 3]);\nset.add(4);\nset.delete(2);\nset.add(1);\n\nconsole.log(set.size);\n```",
    category: 'javascript',
    subcategory: 'map-set',
    difficulty: 'easy',
    options: [
      '3',
      '4',
      '5',
      '2',
    ],
    correctAnswer: 0,
    explanation: "Start with {1, 2, 3}. add(4) ‚Üí {1, 2, 3, 4}. delete(2) ‚Üí {1, 3, 4}. add(1) does nothing (already exists). Final set: {1, 3, 4} with size 3.",
    tags: ['set', 'methods'],
  },

{
    id: 'js-244',
    question: "üìù What's the output?\n\n```javascript\nconst map = new Map([\n  ['a', 1],\n  ['b', 2]\n]);\n\nconsole.log(map.get('a'));\nconsole.log(map.get('c'));\n```",
    category: 'javascript',
    subcategory: 'map-set',
    difficulty: 'easy',
    options: [
      '1 and null',
      '1 and undefined',
      'undefined and undefined',
      '1 and 0',
    ],
    correctAnswer: 1,
    explanation: "map.get(key) returns the value for that key, or undefined if the key doesn't exist. 'a' exists and has value 1. 'c' doesn't exist, so get returns undefined.",
    tags: ['map', 'methods'],
  },

{
    id: 'js-245',
    question: "üìù Which is more efficient for checking if a value exists in a large collection?\n\n```javascript\nconst array = [1, 2, 3, /* ... 10000 items */];\nconst set = new Set([1, 2, 3, /* ... 10000 items */]);\n\narray.includes(9999);\nset.has(9999);\n```",
    category: 'javascript',
    subcategory: 'map-set',
    difficulty: 'medium',
    options: [
      'array.includes() is faster',
      'set.has() is faster',
      'Same performance',
      'Depends on the values',
    ],
    correctAnswer: 1,
    explanation: "set.has() is O(1) average case (constant time lookup using hash table). array.includes() is O(n) (linear search through all elements). For large collections, Set is significantly faster for lookups.",
    tags: ['set', 'performance', 'arrays'],
  },

{
    id: 'js-246',
    question: "üìù What's the output?\n\n```javascript\nconst map = new Map();\nmap.set(NaN, 'value');\n\nconsole.log(map.get(NaN));\nconsole.log(NaN === NaN);\n```",
    category: 'javascript',
    subcategory: 'map-set',
    difficulty: 'hard',
    options: [
      'undefined and false',
      'value and false',
      'undefined and true',
      'value and true',
    ],
    correctAnswer: 1,
    explanation: "Map treats NaN as equal to itself, even though NaN === NaN is false. This is a special case. map.get(NaN) returns 'value' because Map considers all NaN values as the same key.",
    tags: ['map', 'NaN', 'edge-cases'],
  },

{
    id: 'js-247',
    question: "üìù How do you iterate over a Map?\n\n```javascript\nconst map = new Map([['a', 1], ['b', 2]]);\n\nfor (const [key, value] of map) {\n  console.log(key, value);\n}\n```",
    category: 'javascript',
    subcategory: 'map-set',
    difficulty: 'medium',
    options: [
      'Logs: a 1, b 2',
      'Error: Map is not iterable',
      'Logs: [\'a\', 1], [\'b\', 2]',
      'Logs: undefined undefined',
    ],
    correctAnswer: 0,
    explanation: "Map is iterable. for...of iterates over Map entries as [key, value] pairs. Destructuring [key, value] extracts them. This logs 'a 1' then 'b 2'.",
    tags: ['map', 'iteration', 'destructuring'],
  },

{
    id: 'js-248',
    question: "üìù What's the output?\n\n```javascript\nconst set1 = new Set([1, 2, 3]);\nconst set2 = new Set([1, 2, 3]);\n\nconsole.log(set1 === set2);\nconsole.log([...set1].toString() === [...set2].toString());\n```",
    category: 'javascript',
    subcategory: 'map-set',
    difficulty: 'medium',
    options: [
      'true and true',
      'false and true',
      'true and false',
      'false and false',
    ],
    correctAnswer: 1,
    explanation: "set1 and set2 are different object instances, so === is false (reference comparison). Converting both to arrays and then strings gives '1,2,3' for both, so the string comparison is true.",
    tags: ['set', 'references', 'comparison'],
  },

{
    id: 'js-249',
    question: "üìù What's the output?\n\n```javascript\nconst map = new Map();\nmap.set('key', 'value');\n\nconsole.log(map.has('key'));\nmap.clear();\nconsole.log(map.has('key'));\n```",
    category: 'javascript',
    subcategory: 'map-set',
    difficulty: 'easy',
    options: [
      'true and true',
      'true and false',
      'false and false',
      'false and true',
    ],
    correctAnswer: 1,
    explanation: "map.has(key) checks if a key exists. Initially 'key' exists (true). map.clear() removes all entries from the Map. After clearing, 'key' no longer exists (false).",
    tags: ['map', 'methods'],
  },

{
    id: 'js-250',
    question: "üìù What's the output?\n\n```javascript\nconst arr = [1, 2, 2, 3, 3, 3, 4, 4, 4, 4];\nconst unique = [...new Set(arr)];\n\nconsole.log(unique);\n```",
    category: 'javascript',
    subcategory: 'map-set',
    difficulty: 'easy',
    options: [
      '[1, 2, 3, 4]',
      '[1, 2, 2, 3, 3, 3, 4, 4, 4, 4]',
      'Set {1, 2, 3, 4}',
      'Error',
    ],
    correctAnswer: 0,
    explanation: "This is a common pattern to remove duplicates from an array. new Set(arr) creates a Set with unique values {1, 2, 3, 4}. Spreading [...set] converts it back to array [1, 2, 3, 4].",
    tags: ['set', 'arrays', 'patterns'],
  },
];
