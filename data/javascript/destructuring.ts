import { QuizQuestion } from '../../types/quiz';

export const destructuringQuizzes: QuizQuestion[] = [
{
    id: 'js-251',
    question: "üìù What's the output?\n\n```javascript\nconst [a, b] = [1, 2, 3, 4];\nconsole.log(a, b);\n```",
    category: 'javascript',
    subcategory: 'destructuring',
    difficulty: 'easy',
    options: [
      '1 2',
      '[1, 2] [3, 4]',
      '1 [2, 3, 4]',
      'undefined undefined',
    ],
    correctAnswer: 0,
    explanation: "Array destructuring assigns first element to a, second to b. Extra elements are ignored. a gets 1, b gets 2. The values 3 and 4 are not assigned.",
    tags: ['destructuring', 'arrays'],
  },

{
    id: 'js-252',
    question: "üìù What's the output?\n\n```javascript\nconst { name, age } = { name: 'John', age: 30, city: 'NYC' };\nconsole.log(name, age);\n```",
    category: 'javascript',
    subcategory: 'destructuring',
    difficulty: 'easy',
    options: [
      'John 30',
      'undefined undefined',
      '{name: \'John\'} {age: 30}',
      'Error',
    ],
    correctAnswer: 0,
    explanation: "Object destructuring extracts properties by name. name gets 'John', age gets 30. The city property is not destructured and is ignored.",
    tags: ['destructuring', 'objects'],
  },

{
    id: 'js-253',
    question: "üìù What's the output?\n\n```javascript\nconst [a, b, c] = [1, 2];\nconsole.log(a, b, c);\n```",
    category: 'javascript',
    subcategory: 'destructuring',
    difficulty: 'easy',
    options: [
      '1 2 undefined',
      '1 2 null',
      'Error',
      '1 2 0',
    ],
    correctAnswer: 0,
    explanation: "Array destructuring assigns undefined to variables that don't have corresponding values. a gets 1, b gets 2, c has no value so it becomes undefined.",
    tags: ['destructuring', 'arrays'],
  },

{
    id: 'js-254',
    question: "üìù What's the output?\n\n```javascript\nconst { name: personName } = { name: 'Alice' };\nconsole.log(personName);\nconsole.log(name);\n```",
    category: 'javascript',
    subcategory: 'destructuring',
    difficulty: 'medium',
    options: [
      'Alice and ReferenceError',
      'Alice and Alice',
      'Alice and undefined',
      'Error',
    ],
    correctAnswer: 0,
    explanation: "**Destructuring with renaming** - extract a property and give it a new variable name!\n\n**What's happening:**\n```javascript\nconst { name: personName } = { name: 'Alice' };\n//      ^^^^  ^^^^^^^^^^^\n//       |         |\n//    property   new variable name\n```\n\n**Step-by-step:**\n```\n1. Look for 'name' property in object ‚Üí Found: 'Alice'\n2. Create variable 'personName' with that value\n3. NO variable called 'name' is created!\n```\n\n**First console.log:**\n```javascript\nconsole.log(personName);  // 'Alice' ‚úÖ\n// personName exists and has the value\n```\n\n**Second console.log:**\n```javascript\nconsole.log(name);  // ReferenceError ‚ùå\n// No variable 'name' was created!\n```\n\n**The pattern:**\n```javascript\nconst { oldName: newName } = object;\n//      ^^^^^^^  ^^^^^^^^\n//      property  variable created\n\nconsole.log(newName);  // ‚úÖ Works\nconsole.log(oldName);  // ‚ùå ReferenceError\n```\n\n**Real-world use case - avoiding conflicts:**\n```javascript\nconst config = { name: 'MyApp', port: 3000 };\nconst user = { name: 'Alice', age: 25 };\n\n// Without renaming - conflict!\n// const { name } = config;\n// const { name } = user;  // Error: 'name' already declared\n\n// With renaming - no conflict!\nconst { name: appName } = config;\nconst { name: userName } = user;\n\nconsole.log(appName);   // 'MyApp'\nconsole.log(userName);  // 'Alice'\n```\n\n**Memory trick:** The name after the colon is what gets created. Think: \"oldName becomes newName\".",
    tags: ['destructuring', 'objects', 'renaming'],
  },

{
    id: 'js-255',
    question: "üìù What's the output?\n\n```javascript\nconst [a, , b] = [1, 2, 3];\nconsole.log(a, b);\n```",
    category: 'javascript',
    subcategory: 'destructuring',
    difficulty: 'medium',
    options: [
      '1 3',
      '1 2',
      '1 undefined',
      'Error',
    ],
    correctAnswer: 0,
    explanation: "**Skipping elements in array destructuring** - use empty slots!\n\n**What's happening:**\n```javascript\nconst [a, , b] = [1, 2, 3];\n//     ^  ^  ^\n//     |  |  |\n//     |  skip this\n//     |     |\n//   position 0  position 2\n```\n\n**Step-by-step:**\n```\nArray: [1, 2, 3]\n        ‚Üì  ‚Üì  ‚Üì\n        a skip b\n        \na = 1  (first element)\n(skip 2nd element)\nb = 3  (third element)\n```\n\n**Output:**\n```javascript\nconsole.log(a, b);  // 1 3\n```\n\n**More examples:**\n```javascript\n// Skip first element\nconst [, second, third] = ['a', 'b', 'c'];\nconsole.log(second, third);  // 'b' 'c'\n\n// Skip multiple elements\nconst [first, , , fourth] = [1, 2, 3, 4];\nconsole.log(first, fourth);  // 1 4\n\n// Get first and last\nconst [start, , , , end] = [10, 20, 30, 40, 50];\nconsole.log(start, end);  // 10 50\n```\n\n**Memory trick:** Empty comma = skip that spot!",
    tags: ['destructuring', 'arrays'],
  },

{
    id: 'js-256',
    question: "üìù What's the output?\n\n```javascript\nconst { name = 'Anonymous' } = { age: 25 };\nconsole.log(name);\n```",
    category: 'javascript',
    subcategory: 'destructuring',
    difficulty: 'medium',
    options: [
      'Anonymous',
      'undefined',
      'null',
      'Error',
    ],
    correctAnswer: 0,
    explanation: "**Default values in destructuring** - provide fallback when property doesn't exist!\n\n**What's happening:**\n```javascript\nconst { name = 'Anonymous' } = { age: 25 };\n//      ^^^^   ^^^^^^^^^^^^\n//       |           |\n//    property   default value\n```\n\n**Step-by-step:**\n```\n1. Look for 'name' property in { age: 25 }\n2. Property doesn't exist!\n3. Use default value 'Anonymous'\n4. name = 'Anonymous'\n```\n\n**When defaults are used:**\n```javascript\n// Property exists ‚Üí use actual value\nconst { name = 'Anonymous' } = { name: 'Alice' };\nconsole.log(name);  // 'Alice' (actual value)\n\n// Property missing ‚Üí use default\nconst { name = 'Anonymous' } = { age: 25 };\nconsole.log(name);  // 'Anonymous' (default)\n\n// Property is undefined ‚Üí use default\nconst { name = 'Anonymous' } = { name: undefined };\nconsole.log(name);  // 'Anonymous' (default)\n\n// Property is null ‚Üí use null (not default!)\nconst { name = 'Anonymous' } = { name: null };\nconsole.log(name);  // null (actual value)\n```\n\n**Real-world use case:**\n```javascript\nfunction createUser({ name = 'Guest', role = 'user', active = true } = {}) {\n  return { name, role, active };\n}\n\ncreateUser({ name: 'Alice' });  // { name: 'Alice', role: 'user', active: true }\ncreateUser({});                 // { name: 'Guest', role: 'user', active: true }\n```\n\n**Memory trick:** Default = safety net when property is missing or undefined!",
    tags: ['destructuring', 'objects', 'defaults'],
  },

{
    id: 'js-257',
    question: "üìù What's the output?\n\n```javascript\nconst [a, ...rest] = [1, 2, 3, 4, 5];\nconsole.log(a);\nconsole.log(rest);\n```",
    category: 'javascript',
    subcategory: 'destructuring',
    difficulty: 'medium',
    options: [
      '1 and [2, 3, 4, 5]',
      '1 and [1, 2, 3, 4, 5]',
      '[1] and [2, 3, 4, 5]',
      'Error',
    ],
    correctAnswer: 0,
    explanation: "**Rest syntax in destructuring** - gather remaining elements!\n\n**What's happening:**\n```javascript\nconst [a, ...rest] = [1, 2, 3, 4, 5];\n//     ^   ^^^^^^\n//     |      |\n//   first  everything else\n```\n\n**Step-by-step:**\n```\nArray: [1, 2, 3, 4, 5]\n        ‚Üì  ‚Üì  ‚Üì  ‚Üì  ‚Üì\n        a  ....rest....\n        \na = 1 (single value)\nrest = [2, 3, 4, 5] (array of remaining)\n```\n\n**Output:**\n```javascript\nconsole.log(a);     // 1\nconsole.log(rest);  // [2, 3, 4, 5]\n```\n\n**More examples:**\n```javascript\n// Get first two, rest in array\nconst [x, y, ...others] = [10, 20, 30, 40];\nconsole.log(x, y, others);  // 10 20 [30, 40]\n\n// Rest with no remaining = empty array\nconst [first, ...empty] = [1];\nconsole.log(first, empty);  // 1 []\n\n// Can skip and use rest\nconst [, , ...lastTwo] = [1, 2, 3, 4];\nconsole.log(lastTwo);  // [3, 4]\n```\n\n**Important rule:**\n```javascript\n// ‚úÖ Rest must be last\nconst [a, ...rest, b] = [1, 2, 3];  // ‚ùå SyntaxError!\nconst [a, b, ...rest] = [1, 2, 3];  // ‚úÖ Works\n```\n\n**Memory trick:** ...rest = \"give me the rest as an array\"!",
    tags: ['destructuring', 'rest', 'arrays'],
  },

{
    id: 'js-258',
    question: "üìù How do you swap variables using destructuring?\n\n```javascript\nlet a = 1;\nlet b = 2;\n// Swap here\nconsole.log(a, b); // Should log: 2 1\n```",
    category: 'javascript',
    subcategory: 'destructuring',
    difficulty: 'easy',
    options: [
      '[a, b] = [b, a]',
      '{a, b} = {b, a}',
      'a, b = b, a',
      'swap(a, b)',
    ],
    correctAnswer: 0,
    explanation: "[a, b] = [b, a] creates array [2, 1] and destructures it, assigning b's value to a and a's value to b. This swaps the variables without needing a temporary variable.",
    tags: ['destructuring', 'arrays', 'patterns'],
  },

{
    id: 'js-259',
    question: "üìù What's the output?\n\n```javascript\nconst { a: { b } } = { a: { b: 'nested' } };\nconsole.log(b);\nconsole.log(a);\n```",
    category: 'javascript',
    subcategory: 'destructuring',
    difficulty: 'hard',
    options: [
      'nested and ReferenceError',
      'nested and {b: \'nested\'}',
      'undefined and {b: \'nested\'}',
      'Error',
    ],
    correctAnswer: 0,
    explanation: "**Nested destructuring** - dig deep into objects, but watch what variables are created!\n\n**Think of it like a treasure map** - you follow the path but only mark the final spot!\n\n**What's happening:**\n```javascript\nconst { a: { b } } = { a: { b: 'nested' } };\n//      ^    ^\n//      |    |\n//    path  variable created\n```\n\n**Step-by-step:**\n```\n1. Follow path 'a' ‚Üí Find object { b: 'nested' }\n2. Inside that object, destructure 'b'\n3. Create variable b = 'nested'\n4. NO variable 'a' is created! (it's just a path)\n```\n\n**Visualization:**\n```javascript\nObject structure:\n{\n  a: {           ‚Üê Path (not a variable)\n    b: 'nested'  ‚Üê Variable created!\n  }\n}\n\nVariables created:\nb = 'nested' ‚úÖ\na = ??? ‚ùå (doesn't exist)\n```\n\n**Output:**\n```javascript\nconsole.log(b);  // 'nested' ‚úÖ\nconsole.log(a);  // ReferenceError ‚ùå\n```\n\n**How to get both:**\n```javascript\n// Want both? Destructure separately\nconst obj = { a: { b: 'nested' } };\nconst { a } = obj;        // a = { b: 'nested' }\nconst { a: { b } } = obj; // b = 'nested'\n\nconsole.log(a);  // { b: 'nested' } ‚úÖ\nconsole.log(b);  // 'nested' ‚úÖ\n\n// Or use multiple variables in one line\nconst { a, a: { b } } = obj;\nconsole.log(a);  // { b: 'nested' } ‚úÖ\nconsole.log(b);  // 'nested' ‚úÖ\n```\n\n**Real-world example:**\n```javascript\nconst response = {\n  data: {\n    user: {\n      profile: {\n        name: 'Alice',\n        avatar: 'pic.jpg'\n      }\n    }\n  }\n};\n\n// Extract deeply nested value\nconst { data: { user: { profile: { name } } } } = response;\nconsole.log(name);  // 'Alice' ‚úÖ\nconsole.log(data);  // ReferenceError (just a path!)\n```\n\n**Common gotcha:**\n```javascript\n// This does NOT create variable 'user'\nconst { user: { name } } = { user: { name: 'Alice' } };\nconsole.log(name);  // 'Alice' ‚úÖ\nconsole.log(user);  // ReferenceError ‚ùå\n\n// If you want user too, extract it:\nconst { user, user: { name } } = { user: { name: 'Alice' } };\nconsole.log(name);  // 'Alice' ‚úÖ\nconsole.log(user);  // { name: 'Alice' } ‚úÖ\n```\n\n**Memory trick:** Path vs destination - only the destination (final property) becomes a variable!",
    tags: ['destructuring', 'objects', 'nesting'],
  },

{
    id: 'js-260',
    question: "üìù What's the output?\n\n```javascript\nfunction getUser({ name, age = 18 }) {\n  return `${name} is ${age}`;\n}\n\nconsole.log(getUser({ name: 'John' }));\nconsole.log(getUser({ name: 'Jane', age: 25 }));\n```",
    category: 'javascript',
    subcategory: 'destructuring',
    difficulty: 'medium',
    options: [
      'John is undefined and Jane is 25',
      'John is 18 and Jane is 25',
      'Error',
      'John is null and Jane is 25',
    ],
    correctAnswer: 1,
    explanation: "**Destructuring in function parameters** - extract and use defaults in one step!\n\n**What's happening:**\n```javascript\nfunction getUser({ name, age = 18 }) {\n//              ^^^^^^^^  ^^^^^^^^\n//                 |         |\n//            required   optional with default\n  return `${name} is ${age}`;\n}\n```\n\n**Call 1: getUser({ name: 'John' })**\n```javascript\n// Destructure: { name: 'John' }\nname = 'John'  // Provided ‚úÖ\nage = 18       // Not provided, use default ‚úÖ\n\n// Result: \"John is 18\"\n```\n\n**Call 2: getUser({ name: 'Jane', age: 25 })**\n```javascript\n// Destructure: { name: 'Jane', age: 25 }\nname = 'Jane'  // Provided ‚úÖ\nage = 25       // Provided, use it ‚úÖ\n\n// Result: \"Jane is 25\"\n```\n\n**Output:**\n```javascript\nconsole.log(getUser({ name: 'John' }));        // \"John is 18\"\nconsole.log(getUser({ name: 'Jane', age: 25 })); // \"Jane is 25\"\n```\n\n**More examples:**\n```javascript\n// Multiple defaults\nfunction createUser({ name, role = 'guest', active = true }) {\n  return { name, role, active };\n}\n\ncreateUser({ name: 'Alice' });\n// { name: 'Alice', role: 'guest', active: true }\n\ncreateUser({ name: 'Bob', role: 'admin' });\n// { name: 'Bob', role: 'admin', active: true }\n```\n\n**Default for the entire parameter:**\n```javascript\nfunction getUser({ name, age = 18 } = {}) {\n//                                  ^^^^\n//                              empty object default\n  return `${name} is ${age}`;\n}\n\ngetUser();  // undefined is 18 (no error!)\ngetUser({ name: 'Alice' });  // Alice is 18\n```\n\n**Memory trick:** Function parameters can destructure just like variables!",
    tags: ['destructuring', 'functions', 'defaults'],
  },

{
    id: 'js-261',
    question: "üìù What's the output?\n\n```javascript\nconst { ...rest } = { a: 1, b: 2, c: 3 };\nconsole.log(rest);\n```",
    category: 'javascript',
    subcategory: 'destructuring',
    difficulty: 'medium',
    options: [
      '{a: 1, b: 2, c: 3}',
      '{rest: {a: 1, b: 2, c: 3}}',
      'Error',
      'undefined',
    ],
    correctAnswer: 0,
    explanation: "**Object rest in destructuring** - collect remaining properties!\n\n**What's happening:**\n```javascript\nconst { ...rest } = { a: 1, b: 2, c: 3 };\n//      ^^^^^^^^\n//         |\n//    collect everything\n```\n\n**Step-by-step:**\n```\nObject: { a: 1, b: 2, c: 3 }\n          ‚Üì    ‚Üì    ‚Üì\n       ...rest collects all...\n       \nrest = { a: 1, b: 2, c: 3 }\n```\n\n**Output:**\n```javascript\nconsole.log(rest);  // { a: 1, b: 2, c: 3 }\n```\n\n**More useful with extraction:**\n```javascript\n// Extract 'a', rest gets remaining\nconst { a, ...rest } = { a: 1, b: 2, c: 3 };\nconsole.log(a);     // 1\nconsole.log(rest);  // { b: 2, c: 3 }\n\n// Extract multiple, rest gets remaining\nconst { x, y, ...others } = { x: 10, y: 20, z: 30, w: 40 };\nconsole.log(x, y);     // 10 20\nconsole.log(others);   // { z: 30, w: 40 }\n\n// Rest with nothing remaining = empty object\nconst { a, b, c, ...empty } = { a: 1, b: 2, c: 3 };\nconsole.log(empty);  // {}\n```\n\n**Real-world use case:**\n```javascript\n// Exclude certain properties\nconst user = { id: 1, name: 'Alice', password: 'secret', role: 'admin' };\nconst { password, ...safeUser } = user;\n\nconsole.log(safeUser);  // { id: 1, name: 'Alice', role: 'admin' }\n// password excluded!\n```\n\n**Memory trick:** ...rest in objects = \"give me the rest as an object\"!",
    tags: ['destructuring', 'rest', 'objects'],
  },

{
    id: 'js-262',
    question: "üìù What's the output?\n\n```javascript\nconst arr = ['a', 'b', 'c'];\nconst [x, , z] = arr;\nconst [, y] = arr;\n\nconsole.log(x, y, z);\n```",
    category: 'javascript',
    subcategory: 'destructuring',
    difficulty: 'medium',
    options: [
      'a b c',
      'a undefined c',
      'Error',
      'undefined b undefined',
    ],
    correctAnswer: 0,
    explanation: "**Multiple destructuring assignments** - you can destructure the same array multiple times!\n\n**What's happening:**\n```javascript\nconst arr = ['a', 'b', 'c'];\n\n// First destructuring\nconst [x, , z] = arr;\n//     ^  ^  ^\n//     |  skip |\n//   'a'     'c'\n\n// Second destructuring (same array!)\nconst [, y] = arr;\n//     ^ ^\n//    skip |\n//       'b'\n```\n\n**Step-by-step:**\n```\nFirst: [x, , z] = ['a', 'b', 'c']\n        ‚Üì  skip  ‚Üì\n       x='a'    z='c'\n\nSecond: [, y] = ['a', 'b', 'c']\n        skip ‚Üì\n            y='b'\n\nFinal values:\nx = 'a'\ny = 'b'\nz = 'c'\n```\n\n**Output:**\n```javascript\nconsole.log(x, y, z);  // a b c\n```\n\n**Key insight - array isn't consumed:**\n```javascript\nconst nums = [1, 2, 3, 4, 5];\n\n// First destructuring\nconst [a, b] = nums;\nconsole.log(a, b);  // 1 2\n\n// Second destructuring (same array!)\nconst [, , c, d] = nums;\nconsole.log(c, d);  // 3 4\n\n// Array unchanged\nconsole.log(nums);  // [1, 2, 3, 4, 5]\n```\n\n**Real-world pattern:**\n```javascript\nconst data = ['Alice', 'alice@example.com', '555-1234', 'New York'];\n\n// Extract different parts as needed\nconst [name] = data;                    // name = 'Alice'\nconst [, email] = data;                 // email = 'alice@example.com'\nconst [, , phone, city] = data;         // phone = '555-1234', city = 'New York'\n```\n\n**Memory trick:** Each destructuring is independent - the source array stays the same!",
    tags: ['destructuring', 'arrays'],
  },

{
    id: 'js-049',
    question: "üñ•Ô∏è What's the output?\n\n```javascript\nconst { firstName: myName } = { firstName: \"Lydia\" };\n\nconsole.log(firstName);\n```",
    category: 'javascript',
    subcategory: 'destructuring',
    difficulty: 'medium',
    options: [
          "\"Lydia\"",
          "\"myName\"",
          "undefined",
          "ReferenceError"
    ],
    correctAnswer: 3,
    explanation: "**Destructuring with renaming** - the original property name doesn't become a variable!\n\n**What happens:**\n```javascript\nconst { firstName: myName } = { firstName: \"Lydia\" };\n```\n\n**Syntax breakdown:**\n```\n{ propertyName: newVariableName } = object\n       ‚Üì              ‚Üì\n    What to        What variable\n    extract        to create\n```\n\n**Step-by-step:**\n```javascript\n// 1. Extract firstName property from object\n// 2. Create variable myName with that value\n// 3. NO variable called firstName is created!\n\nconsole.log(myName);      // \"Lydia\" ‚úÖ\nconsole.log(firstName);   // ReferenceError ‚ùå\n```\n\n**The rule: Renaming creates ONLY the new variable name**\n\n**Comparison:**\n```javascript\n// Without renaming - creates variable 'firstName'\nconst { firstName } = { firstName: \"Lydia\" };\nconsole.log(firstName);  // \"Lydia\" ‚úÖ\n\n// With renaming - creates variable 'myName' ONLY\nconst { firstName: myName } = { firstName: \"Lydia\" };\nconsole.log(myName);      // \"Lydia\" ‚úÖ\nconsole.log(firstName);   // ReferenceError ‚ùå\n```\n\n**Real-world examples:**\n```javascript\n// Rename to avoid conflicts\nconst config = { name: 'app', version: '1.0' };\nconst user = { name: 'John', age: 25 };\n\nconst { name: appName } = config;\nconst { name: userName } = user;\n\nconsole.log(appName);   // 'app'\nconsole.log(userName);  // 'John'\n\n// Rename for clarity\nconst { data: users } = await fetchUsers();\nconst { data: posts } = await fetchPosts();\n\n// Rename deeply nested properties\nconst { user: { profile: { avatar: profilePic } } } = response;\n```\n\n**Common gotcha - global scope properties:**\n```javascript\nconst { name: myName } = { name: \"Lydia\" };\n\nconsole.log(myName);  // \"Lydia\"\nconsole.log(name);    // Depends on environment!\n                      // Browser: \"\" (window.name exists)\n                      // Node.js: ReferenceError (no global 'name')\n```\n\n**Why this behavior?**\nBrowsers have a deprecated `window.name` property, so `name` doesn't throw ReferenceError in browsers‚Äîit accesses the global property instead!\n\n**Memory trick:**\n- `{ prop: newName }` = Extract prop, create newName\n- Original property name is NOT a variable\n- Only the name after `:` becomes a variable",
    tags: ["destructuring","objects","renaming"],
  },
];
